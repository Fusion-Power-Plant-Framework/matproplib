{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":"<p>The matproplib package provides an interface for material properties.</p> <p>The main aim of this package is to unite structural, thermal, electro-magnetic and neutronics properties under one interface.</p>"},{"location":"#contents","title":"Contents","text":"<ul> <li>Material properties</li> <li>Operational conditions</li> <li>Superconducting parameterisations</li> <li>Format Converters (Neutronics, FEM, etc.)</li> </ul>"},{"location":"conditions/","title":"Operational conditions","text":"<p>Material properties depend on the operational conditions to which the material is subjected. Most commonly, material property parameterisations are temperature-dependent. However, parameterisations may exist for a wide variety of other conditions, such as magnetic field and radiation damage.</p> <p>In <code>matproplib</code> all material properties are called with an <code>OperationalConditions</code> object. The following fields are available by default:</p> Operational Condition Name Units Definition temperature K Operational temperature. pressure Pa Operational pressure (fluids). magnetic_field T Operational magnetic field. strain \u2014 Operational strain. neutron_damage dpa Operational neutron damage (displacements per atom). neutron_fluence 1/m^2 Operational neutron fluence."},{"location":"conversions/","title":"Format Conversions","text":"<p>Materials are often needed in specific formats for a given code. We aim to offer a variety of converter to different formats where direct interfacing cannot easily be achieved.</p> <p>We currently offer coverters to a few select neutronics packages but this area will be expanded as the <code>matproplib</code> matures.</p>"},{"location":"conversions/#neutronics-converters","title":"Neutronics Converters","text":"<p>We offer converters to OpenMC, Serpent, Fispact and MCNP6. The OpenMC converter requires OpenMC installed as it produces an OpenMC python material. All of the other converters output a text string and can be run without any extra dependencies.</p>"},{"location":"conversions/#usage","title":"Usage","text":"<p>To use any converter they need to be added to a material, this can be done at definition or during use. The individual converters have some configuration options if required.</p> <pre><code>from matproplib.converters.neutronics import MCNPNeutronicConfig, OpenMCNeutronicConfig\nfrom matproplib.properties.group import props\nfrom matproplib.material import material\n\nSteel = material(\n    \"Steel\",\n    elements=\"C1Fe12\",\n    properties=props(\n        density=5,\n        specific_heat_capacity=6\n    ),\n    converters=MCNPNeutronicConfig(), # alternatively a list of converters\n)\n\nmy_steel = Steel()\nmy_steel.converters.add(OpenMCNeutronicConfig())\n</code></pre> <p>To convert a material to a given format use the <code>convert</code> function on the material. The converter name is defined as a variable on the converter class:</p> <pre><code>from matproplib.conditions import OperationalConditions\nfrom matproplib.converters.neutronics import MCNPNeutronicConfig\n\nop_cond = OperationalConditions(temperature=298)\n\n# converter name equivalent to 'mcnp'\nmcnp_mat = my_steel.convert(MCNPNeutronicConfig.name, op_cond)\n</code></pre> <p>All neutronics converters translate elements to thier natural nucleide abundances. The nucleides are then combined with any other isotopes on the material.</p>"},{"location":"properties/","title":"Material properties","text":"<p><code>matproplib</code> defines some standard material property names. These are:</p> Property Name Units Definition density kg/m\u00b3 Density of a material. poissons_ratio \u2014 Poisson's ratio. residual_resistance_ratio \u2014 Residual resistance ratio. youngs_modulus Pa Young's modulus. shear_modulus Pa Shear modulus. bulk_modulus Pa Bulk modulus. thermal_conductivity W\u00b7m/K Thermal conductivity. coefficient_thermal_expansion K\u207b\u00b9 Coefficient of thermal expansion (CTE). specific_heat_capacity J/kg/K Specific heat capacity. electrical_resistivity \u03a9\u00b7m Electrical resistivity. magnetic_saturation A\u00b7m\u00b2/kg Magnetic saturation. magnetic_susceptibility \u2014 Magnetic susceptibility. viscous_remanent_magnetisation A\u00b7m\u00b2/kg Viscous remanent magnetisation. coercive_field A/m Coercive field. minimum_yield_stress Pa Minimum yield stress. average_yield_stress Pa Average yield stress. minimum_ultimate_tensile_stress Pa Minimum ultimate tensile stress. average_ultimate_tensile_stress Pa Average ultimate tensile stress."},{"location":"superconductors/","title":"Superconductors","text":""},{"location":"superconductors/#superconducting-parameterisations","title":"Superconducting parameterisations","text":"<p>Superconductors are often characterised by their critical surface in terms of the current density as a function of applied temperature, magnetic field, and strain: \\(J_c(T,B,\\varepsilon)\\).</p> <p>Superconducting parameterisations take many forms. At present, three formulations are provided:</p> <ul> <li>Summers parameterisation</li> <li>Bottura-Bordini Nb<sub>3</sub>Sn parameterisation</li> <li>Bottura NbTi parameterisation</li> </ul> <p>Each parameterisation takes a range of free parameters. For example, one can instantiate a superconducting parameterisation:</p> <p><pre><code>from matproplib.superconduction import Nb3SnBotturaParameterisation\n\nNBS3N_WST_TF_STRAND = Nb3SnBotturaParameterisation(\n    constant=83075.0e6,\n    p=0.593,\n    q=2.156,\n    c_a1=50.06,\n    c_a2=0.0,\n    eps_0a=0.00312,\n    eps_m=-0.00059,\n    b_c20m=33.24,\n    t_c0max=16.34,\n    name=\"Nb3Sn WST TF Strand\",\n)\n</code></pre> Values above from Corato et al..</p>"},{"location":"superconductors/#superconducting-materials","title":"Superconducting materials","text":"<p>A superconducting material can be specified by assigning it a <code>superconducting_parameterisation</code>. Doing so will endow it with an additional material property: <code>critical_current_density</code> [A/m<sup>2</sup>]</p> <pre><code>from matproplib.material import material\nfrom matproplib.properties.group import props\nfrom matproplib.conditions import OperationalConditions\nNb3Sn = material(\n    \"Nb3Sn\",\n    elements=\"Nb3Sn\",\n    properties=props(\n        as_field=True,\n        density=8040.0,\n        superconducting_parameterisation=NBS3N_WST_TF_STRAND,\n    )\n)\nmyNb3Sn = Nb3Sn()\nop_cond = OperationalConditions(temperature=4.7, magnetic_field=13, strain=-0.0055)\nprint(f\"J_c = {myNb3Sn.critical_current_density(op_cond)/1e6} A/mm^2\")\n</code></pre> <p>N.B.: The formulations of these superconducting parameterisations is invariably such that negative or NaN results can be obtained if the operational conditions would drive the superconductor to no longer be superconducting. A variety of numerical fudges are employed here to ensure that the results are always positive or 0.0. These fudges will affect the critical current density around the transition region (at very low current densities). Results at very low current densities (&lt; 20 A/m<sup>2</sup>) should not be trusted.</p>"},{"location":"examples/basic_usage.ex/","title":"Usage Overview","text":"In\u00a0[\u00a0]: remove-cell Copied! <pre># SPDX-FileCopyrightText: 2025-present The Bluemira Developers &lt;https://github.com/Fusion-Power-Plant-Framework/bluemira&gt;\n#\n# SPDX-License-Identifier: LGPL-2.1-or-later\n\n\"\"\"An example to show the basic usage of matproplib\"\"\"\n</pre> # SPDX-FileCopyrightText: 2025-present The Bluemira Developers  # # SPDX-License-Identifier: LGPL-2.1-or-later  \"\"\"An example to show the basic usage of matproplib\"\"\" In\u00a0[\u00a0]: Copied! <pre>from typing import Literal\n\nfrom pint import Unit\n\nfrom matproplib.base import rebuild\nfrom matproplib.conditions import OperationalConditions\nfrom matproplib.converters.neutronics import (\n    FispactNeutronicConfig,\n    MCNPNeutronicConfig,\n    OpenMCNeutronicConfig,\n)\nfrom matproplib.material import FullMaterial, dependentphysicalproperty, material\nfrom matproplib.properties.dependent import (\n    Density,\n    ResidualResistanceRatio,\n    SpecificHeatCapacity,\n)\nfrom matproplib.properties.group import DefaultProperties, Properties, props\nfrom matproplib.properties.independent import PhysicalProperty, pp\nfrom matproplib.superconduction import NbTiBotturaParameterisation\n</pre> from typing import Literal  from pint import Unit  from matproplib.base import rebuild from matproplib.conditions import OperationalConditions from matproplib.converters.neutronics import (     FispactNeutronicConfig,     MCNPNeutronicConfig,     OpenMCNeutronicConfig, ) from matproplib.material import FullMaterial, dependentphysicalproperty, material from matproplib.properties.dependent import (     Density,     ResidualResistanceRatio,     SpecificHeatCapacity, ) from matproplib.properties.group import DefaultProperties, Properties, props from matproplib.properties.independent import PhysicalProperty, pp from matproplib.superconduction import NbTiBotturaParameterisation In\u00a0[\u00a0]: Copied! <pre>op_cond = OperationalConditions(temperature=298, pressure=(1, \"atm\"))\nprint(op_cond)\n</pre> op_cond = OperationalConditions(temperature=298, pressure=(1, \"atm\")) print(op_cond) <p>More complex conditions can be created adding a new independent physical property. This can be achieve via inheriting from PhysicalProperty or using the <code>pp</code> helper function</p> In\u00a0[\u00a0]: Copied! <pre># class CurrentDensity(PhysicalProperty):\n#     unit: Unit | str = \"A/m^2\"\n\nCurrentDensity = pp(\"CurrentDensity\", \"A/m^2\")\n\n\nclass SpecialConditions(OperationalConditions):\n    \"\"\"Example conditions object\"\"\"\n\n    current_density: CurrentDensity\n\n\nsp_op_cond = SpecialConditions(temperature=5, pressure=(1, \"atm\"), current_density=3)\nprint(sp_op_cond)\n</pre> # class CurrentDensity(PhysicalProperty): #     unit: Unit | str = \"A/m^2\"  CurrentDensity = pp(\"CurrentDensity\", \"A/m^2\")   class SpecialConditions(OperationalConditions):     \"\"\"Example conditions object\"\"\"      current_density: CurrentDensity   sp_op_cond = SpecialConditions(temperature=5, pressure=(1, \"atm\"), current_density=3) print(sp_op_cond) In\u00a0[\u00a0]: Copied! <pre># class MyMaterial(Material):\n#     name: str = \"MyMaterial\"\n\nMyMaterial = material(\"MyMaterial\")\n</pre> # class MyMaterial(Material): #     name: str = \"MyMaterial\"  MyMaterial = material(\"MyMaterial\") In\u00a0[\u00a0]: Copied! <pre>my_material_inst = MyMaterial()\nprint(my_material_inst)\n</pre> my_material_inst = MyMaterial() print(my_material_inst) In\u00a0[\u00a0]: Copied! <pre>Unobtainium = material(\n    \"Unobtainium\", elements={\"H\": 0.1, \"He\": 0.2, \"Li\": 0.3, \"Be\": 0.4}\n)\nunob = Unobtainium()\nprint(unob)\n</pre> Unobtainium = material(     \"Unobtainium\", elements={\"H\": 0.1, \"He\": 0.2, \"Li\": 0.3, \"Be\": 0.4} ) unob = Unobtainium() print(unob) <p>Or from a chemical formula</p> In\u00a0[\u00a0]: Copied! <pre>Unobtainium = material(\"Unobtainium\", elements=\"HHe(Be5(Li2He)2)3\")\nunob = Unobtainium()\nprint(unob)\n</pre> Unobtainium = material(\"Unobtainium\", elements=\"HHe(Be5(Li2He)2)3\") unob = Unobtainium() print(unob) <p>Isotopes cannot be specified from a formula but can be achieved like so</p> In\u00a0[\u00a0]: Copied! <pre>Unobtainium = material(\n    \"Unobtainium\", elements={\"H2\": 0.1, \"H3\": 0.2, \"He4\": 0.3, \"Li6\": 0.4}\n)\nunob = Unobtainium()\nprint(unob)\n</pre> Unobtainium = material(     \"Unobtainium\", elements={\"H2\": 0.1, \"H3\": 0.2, \"He4\": 0.3, \"Li6\": 0.4} ) unob = Unobtainium() print(unob) In\u00a0[\u00a0]: Copied! <pre>CurrentDensity = pp(\"CurrentDensity\", \"A/m^2\")\ncd = CurrentDensity(value=(5, \"MA/m^2\"))\nprint(cd)\n</pre> CurrentDensity = pp(\"CurrentDensity\", \"A/m^2\") cd = CurrentDensity(value=(5, \"MA/m^2\")) print(cd) In\u00a0[\u00a0]: Copied! <pre>shc = SpecificHeatCapacity(value=lambda op_cond: 5 * op_cond.temperature)\nprint(shc(op_cond), f\"{shc.unit:~P}\")\n</pre> shc = SpecificHeatCapacity(value=lambda op_cond: 5 * op_cond.temperature) print(shc(op_cond), f\"{shc.unit:~P}\") In\u00a0[\u00a0]: Copied! <pre># With convertable units\nden = Density(value=5, unit=\"pound/ft^3\")\nprint(f\"{den(op_cond):.2f}\", f\"{den.unit:~P}\")\n</pre> # With convertable units den = Density(value=5, unit=\"pound/ft^3\") print(f\"{den(op_cond):.2f}\", f\"{den.unit:~P}\") <p>A parameterisation may only valid within a range of operating conditions or use a specific condition unit for calculation.</p> In\u00a0[\u00a0]: Copied! <pre>den = Density(\n    value=lambda op_cond: op_cond.pressure**2,\n    op_cond_config={\"pressure\": (\"millibar\", 1, 100)},\n)\n\ntry:\n    den(op_cond)\nexcept ValueError as ve:\n    print(ve)\n</pre> den = Density(     value=lambda op_cond: op_cond.pressure**2,     op_cond_config={\"pressure\": (\"millibar\", 1, 100)}, )  try:     den(op_cond) except ValueError as ve:     print(ve) <p>The default set of dependent properties can be created using the <code>props</code> function. Only properties specifed will be created. Alternatively all are defined when using the <code>DefaultProperties</code> class.</p> <p>When grouped dependent properties can also depend on each other.</p> In\u00a0[\u00a0]: Copied! <pre>myprops = props(\n    specific_heat_capacity={\n        \"value\": lambda properties, op_cond: properties.density(op_cond)\n        * op_cond.temperature\n    },\n    density=lambda oc: oc.pressure * 5,\n    superconducting_parameterisation=NbTiBotturaParameterisation(\n        alpha=1,\n        beta=2,\n        gamma=3,\n        constant=4,\n        t_c0=5,\n        b_c20=6,\n        critical_current_density=7,  # overriding default\n    ),\n)\nprint(myprops)\nprint(myprops.specific_heat_capacity(op_cond))\n</pre> myprops = props(     specific_heat_capacity={         \"value\": lambda properties, op_cond: properties.density(op_cond)         * op_cond.temperature     },     density=lambda oc: oc.pressure * 5,     superconducting_parameterisation=NbTiBotturaParameterisation(         alpha=1,         beta=2,         gamma=3,         constant=4,         t_c0=5,         b_c20=6,         critical_current_density=7,  # overriding default     ), ) print(myprops) print(myprops.specific_heat_capacity(op_cond)) In\u00a0[\u00a0]: Copied! <pre>my_def_props = DefaultProperties(density=5)\nprint(my_def_props)\n</pre> my_def_props = DefaultProperties(density=5) print(my_def_props) <p>You can add properties to a material when you define it</p> In\u00a0[\u00a0]: Copied! <pre>Unobtainium = material(\n    \"Unobtainium\",\n    elements={\"H2\": 0.1, \"H3\": 0.2, \"He4\": 0.3, \"Li6\": 0.4},\n    properties=myprops,\n)\nunob = Unobtainium()\nprint(unob)\n</pre> Unobtainium = material(     \"Unobtainium\",     elements={\"H2\": 0.1, \"H3\": 0.2, \"He4\": 0.3, \"Li6\": 0.4},     properties=myprops, ) unob = Unobtainium() print(unob) In\u00a0[\u00a0]: Copied! <pre>m_op_cond = OperationalConditions(temperature=1, pressure=2, magnetic_field=3)\nprint(\n    unob.superconducting_parameterisation.critical_current_density(m_op_cond),\n    f\"{unob.superconducting_parameterisation.critical_current_density.unit:~P}\",\n)\n</pre> m_op_cond = OperationalConditions(temperature=1, pressure=2, magnetic_field=3) print(     unob.superconducting_parameterisation.critical_current_density(m_op_cond),     f\"{unob.superconducting_parameterisation.critical_current_density.unit:~P}\", ) In\u00a0[\u00a0]: Copied! <pre>n_props_openmc = OpenMCNeutronicConfig(enrichment_target=\"Li6\")\n\nn_props = FispactNeutronicConfig(volume=(3, \"cm^3\"))\n</pre> n_props_openmc = OpenMCNeutronicConfig(enrichment_target=\"Li6\")  n_props = FispactNeutronicConfig(volume=(3, \"cm^3\")) In\u00a0[\u00a0]: Copied! <pre>n_unob = Unobtainium(properties=myprops, converters=n_props)\nn_unob.convert(\"fispact\", op_cond)\n</pre> n_unob = Unobtainium(properties=myprops, converters=n_props) n_unob.convert(\"fispact\", op_cond) In\u00a0[\u00a0]: Copied! <pre>Steel = material(\n    \"Steel\",\n    elements=\"C1Fe12\",\n    properties=props(\n        density=5,\n        specific_heat_capacity={\n            \"value\": lambda properties, oc: properties.density(oc) * oc.temperature,\n            \"unit\": \"J/g/K\",\n            \"op_cond_config\": {\"temperature\": (\"K\", 100, 300)},\n        },\n        superconducting_parameterisation=NbTiBotturaParameterisation(\n            alpha=1,\n            beta=2,\n            gamma=3,\n            constant=4,\n            t_c0=5,\n            b_c20=6,\n        ),\n    ),\n    converters=FispactNeutronicConfig(volume=3),\n)\nop_cond = OperationalConditions(temperature=298, pressure=(1, \"atm\"), magnetic_field=5)\nsteel = Steel()  # Initialised using defaults\nprint(steel.critical_current_density(op_cond))\nprint(steel.specific_heat_capacity(op_cond))\nprint()\nprint(steel.convert(\"fispact\", op_cond))\n</pre> Steel = material(     \"Steel\",     elements=\"C1Fe12\",     properties=props(         density=5,         specific_heat_capacity={             \"value\": lambda properties, oc: properties.density(oc) * oc.temperature,             \"unit\": \"J/g/K\",             \"op_cond_config\": {\"temperature\": (\"K\", 100, 300)},         },         superconducting_parameterisation=NbTiBotturaParameterisation(             alpha=1,             beta=2,             gamma=3,             constant=4,             t_c0=5,             b_c20=6,         ),     ),     converters=FispactNeutronicConfig(volume=3), ) op_cond = OperationalConditions(temperature=298, pressure=(1, \"atm\"), magnetic_field=5) steel = Steel()  # Initialised using defaults print(steel.critical_current_density(op_cond)) print(steel.specific_heat_capacity(op_cond)) print() print(steel.convert(\"fispact\", op_cond)) In\u00a0[\u00a0]: Copied! <pre>class Steel(FullMaterial[Literal[\"mcnp\"], NbTiBotturaParameterisation]):\n    \"\"\"Custom material through inheritance\"\"\"\n\n    name: str = \"Steel\"\n\n\nsteel = Steel(\n    elements=\"CFe12\",\n    density=5,\n    specific_heat_capacity=6,\n    superconducting_parameterisation=NbTiBotturaParameterisation(\n        alpha=1,\n        beta=2,\n        gamma=3,\n        constant=4,\n        t_c0=5,\n        b_c20=6,\n    ),\n    converters=MCNPNeutronicConfig(),\n)\n\nprint(steel)\n\n# Steel being statically typed means that this will work but isnt recognised in typing\nsteel.converters.add(FispactNeutronicConfig(volume=5))\nsteel.convert(\"fispact\", op_cond)\n</pre>   class Steel(FullMaterial[Literal[\"mcnp\"], NbTiBotturaParameterisation]):     \"\"\"Custom material through inheritance\"\"\"      name: str = \"Steel\"   steel = Steel(     elements=\"CFe12\",     density=5,     specific_heat_capacity=6,     superconducting_parameterisation=NbTiBotturaParameterisation(         alpha=1,         beta=2,         gamma=3,         constant=4,         t_c0=5,         b_c20=6,     ),     converters=MCNPNeutronicConfig(), )  print(steel)  # Steel being statically typed means that this will work but isnt recognised in typing steel.converters.add(FispactNeutronicConfig(volume=5)) steel.convert(\"fispact\", op_cond) <p>Alternatively you can create a material using an existing properties object</p> In\u00a0[\u00a0]: Copied! <pre>@rebuild  # required when using the dependentphysicalproperty decorator\nclass MyProperties(Properties):\n    \"\"\"Custom property class\"\"\"\n\n    density: Density = 6\n    specific_heat_capacity: SpecificHeatCapacity = 7\n    superconducting_parameterisation: NbTiBotturaParameterisation | None = None\n\n    @dependentphysicalproperty(ResidualResistanceRatio)\n    def residual_resistance_ratio(self, op_cond):\n        \"\"\"Default residual_resistance_ratio dependent property\"\"\"\n        return self.density(op_cond) * op_cond.temperature\n\n\nproperties = MyProperties(\n    density=5,\n    specific_heat_capacity=6,\n    superconducting_parameterisation=NbTiBotturaParameterisation(\n        alpha=1,\n        beta=2,\n        gamma=3,\n        constant=4,\n        t_c0=5,\n        b_c20=6,\n    ),\n)\n\nsteel = Steel(\n    elements=\"CFe12\",\n    properties=properties,\n    converters=MCNPNeutronicConfig(),\n)\n\nprint(steel)\n</pre> @rebuild  # required when using the dependentphysicalproperty decorator class MyProperties(Properties):     \"\"\"Custom property class\"\"\"      density: Density = 6     specific_heat_capacity: SpecificHeatCapacity = 7     superconducting_parameterisation: NbTiBotturaParameterisation | None = None      @dependentphysicalproperty(ResidualResistanceRatio)     def residual_resistance_ratio(self, op_cond):         \"\"\"Default residual_resistance_ratio dependent property\"\"\"         return self.density(op_cond) * op_cond.temperature   properties = MyProperties(     density=5,     specific_heat_capacity=6,     superconducting_parameterisation=NbTiBotturaParameterisation(         alpha=1,         beta=2,         gamma=3,         constant=4,         t_c0=5,         b_c20=6,     ), )  steel = Steel(     elements=\"CFe12\",     properties=properties,     converters=MCNPNeutronicConfig(), )  print(steel)"},{"location":"examples/basic_usage.ex/#usage-overview","title":"Usage Overview\u00b6","text":""},{"location":"examples/basic_usage.ex/#basics","title":"Basics\u00b6","text":"\u26a0\ufe0f All material and property definitions are for example purposes they dont necessarily represent actual quantities or materials."},{"location":"examples/basic_usage.ex/#conditions","title":"Conditions\u00b6","text":"<p>All materials are affected by the conditions they are in. For properties of a material that are dependent on conditions <code>OperationConditions</code> should be passed as an argument to the property. By default <code>OperationalConditions</code> contains:</p> <ul> <li>Temperature</li> <li>Pressure</li> <li>Magnetic Field</li> <li>Stress</li> <li>Neutron Fluence</li> <li>Neutron Damage</li> </ul> <p>The only conditions required is temperature</p>"},{"location":"examples/basic_usage.ex/#material","title":"Material\u00b6","text":"<p>You can create a material either with the <code>material</code> function or via inheriting from <code>Material</code>. When creating a material via inheritance all fields need full typing specification and is therefore considered a more advanced usecase. The <code>material</code> function handles this internally allowing for straightforward material creation.</p>"},{"location":"examples/basic_usage.ex/#elements","title":"Elements\u00b6","text":"<p>You can specify elements in a material like so</p>"},{"location":"examples/basic_usage.ex/#properties","title":"Properties\u00b6","text":"<p>Properties come in two forms dependent and independent.</p>"},{"location":"examples/basic_usage.ex/#independent","title":"Independent\u00b6","text":"<p>Independent properties have already been shown and are just a number with a unit. These are generally used for conditions.</p> <p>Notice the created property is converted to the default units.</p>"},{"location":"examples/basic_usage.ex/#dependent","title":"Dependent\u00b6","text":"<p>Dependent properties are dependent on any operational condition, they can also be singular values.</p>"},{"location":"examples/basic_usage.ex/#superconducting-parameterisations","title":"Superconducting Parameterisations\u00b6","text":"<p>Superconducting information can be provided as part of the properties as seen above. This enables the calculation of critical current density</p>"},{"location":"examples/basic_usage.ex/#neutronics-properties-and-code-material-conversion","title":"Neutronics Properties and Code Material Conversion\u00b6","text":"<p>When using materials as part of neutronics calculations some finer details about the material can be required. These details are usually code specific</p>"},{"location":"examples/basic_usage.ex/#full-functional-material","title":"Full functional material\u00b6","text":""},{"location":"examples/basic_usage.ex/#advanced-usage","title":"Advanced Usage\u00b6","text":""},{"location":"examples/basic_usage.ex/#complete-specification-using-a-classes","title":"Complete specification using a classes\u00b6","text":"<p>Defaults can be added to the class specification if required. They can still be overwritten.</p>"},{"location":"examples/library_material.ex/","title":"Library Materials","text":"In\u00a0[\u00a0]: remove-cell Copied! <pre># SPDX-FileCopyrightText: 2025-present The Bluemira Developers &lt;https://github.com/Fusion-Power-Plant-Framework/bluemira&gt;\n#\n# SPDX-License-Identifier: LGPL-2.1-or-later\n\n\"\"\"An example to show the use of a matproplib material\"\"\"\n</pre> # SPDX-FileCopyrightText: 2025-present The Bluemira Developers  # # SPDX-License-Identifier: LGPL-2.1-or-later  \"\"\"An example to show the use of a matproplib material\"\"\" In\u00a0[\u00a0]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom matproplib.conditions import OperationalConditions\nfrom matproplib.library.copper import CryogenicCopper\n</pre> import matplotlib.pyplot as plt import numpy as np  from matproplib.conditions import OperationalConditions from matproplib.library.copper import CryogenicCopper In\u00a0[\u00a0]: Copied! <pre>copper = CryogenicCopper()\n</pre> copper = CryogenicCopper() <p>We can then set up some conditions at which we want to evaluate some material property. Here we take a look at the electrical resistivity of Copper in cryogenic conditions, which is senstive to temperature, magnetic field, and neutron fluence.</p> In\u00a0[\u00a0]: Copied! <pre>temperatures = np.linspace(4, 100, 50)  # Temperatures from 4 K to 100 K\n\nzero_fluence_conditions = [\n    OperationalConditions(temperature=t, magnetic_field=10.0, neutron_fluence=0.0)\n    for t in temperatures\n]\nresistivity_zero_fluence = [\n    copper.electrical_resistivity(c) for c in zero_fluence_conditions\n]\n\nfluence = 1e22\nfluence_conditions = [\n    OperationalConditions(temperature=t, magnetic_field=10.0, neutron_fluence=fluence)\n    for t in temperatures\n]\nresistivity_fluence = [copper.electrical_resistivity(c) for c in fluence_conditions]\n</pre> temperatures = np.linspace(4, 100, 50)  # Temperatures from 4 K to 100 K  zero_fluence_conditions = [     OperationalConditions(temperature=t, magnetic_field=10.0, neutron_fluence=0.0)     for t in temperatures ] resistivity_zero_fluence = [     copper.electrical_resistivity(c) for c in zero_fluence_conditions ]  fluence = 1e22 fluence_conditions = [     OperationalConditions(temperature=t, magnetic_field=10.0, neutron_fluence=fluence)     for t in temperatures ] resistivity_fluence = [copper.electrical_resistivity(c) for c in fluence_conditions] <p>And simply plot the results.</p> In\u00a0[\u00a0]: Copied! <pre>f, ax = plt.subplots()\n\nax.plot(temperatures, resistivity_zero_fluence, label=\"fluence=0.0\")\nax.plot(temperatures, resistivity_fluence, label=f\"fluence={fluence:.1e}\")\nax.legend()\nax.set_xlabel(\"Temperature (K)\")\nax.set_ylabel(\"Electrical Resistivity (Ohm m)\")\nplt.show()\n</pre> f, ax = plt.subplots()  ax.plot(temperatures, resistivity_zero_fluence, label=\"fluence=0.0\") ax.plot(temperatures, resistivity_fluence, label=f\"fluence={fluence:.1e}\") ax.legend() ax.set_xlabel(\"Temperature (K)\") ax.set_ylabel(\"Electrical Resistivity (Ohm m)\") plt.show()"},{"location":"examples/library_material.ex/#library-materials","title":"Library Materials\u00b6","text":"<p>We can import an existing material from the <code>matproplib</code> library. Here we use the <code>CryogenicCopper</code> material, which is a collection of some material property parameterisations, largely from NIST.</p>"},{"location":"examples/mixture.ex/","title":"Material Mixtures","text":"In\u00a0[\u00a0]: remove-cell Copied! <pre># SPDX-FileCopyrightText: 2025-present The Bluemira Developers &lt;https://github.com/Fusion-Power-Plant-Framework/bluemira&gt;\n#\n# SPDX-License-Identifier: LGPL-2.1-or-later\n\n\"\"\"An example to show how to create a mixture in `matproplib`\"\"\"\n</pre> # SPDX-FileCopyrightText: 2025-present The Bluemira Developers  # # SPDX-License-Identifier: LGPL-2.1-or-later  \"\"\"An example to show how to create a mixture in `matproplib`\"\"\" In\u00a0[\u00a0]: Copied! <pre>from matproplib.conditions import OperationalConditions\nfrom matproplib.library.fluids import Water\nfrom matproplib.library.steel import SS316_L\nfrom matproplib.material import mixture\n</pre> from matproplib.conditions import OperationalConditions from matproplib.library.fluids import Water from matproplib.library.steel import SS316_L from matproplib.material import mixture <p>Let us create the base materials first.</p> In\u00a0[\u00a0]: Copied! <pre>steel = SS316_L()\nwater = Water()\n</pre> steel = SS316_L() water = Water() <p>Now we can create a mixture of these two materials. We will define the mass fractions of steel and water in the mixture. For example, we can create a mixture with 70% steel and 30% water.</p> In\u00a0[\u00a0]: Copied! <pre>my_mixture = mixture(\n    \"SteelWaterMixture\", [(steel, 0.7), (water, 0.3)], fraction_type=\"mass\"\n)\n</pre> my_mixture = mixture(     \"SteelWaterMixture\", [(steel, 0.7), (water, 0.3)], fraction_type=\"mass\" ) <p>We can now use this mixture material in our simulations. For example, we can evaluate the density of the mixture at a given temperature. Mixture properties are computed as a weighted average of the underlying material properties, assuming a homogenous mixture.</p> In\u00a0[\u00a0]: Copied! <pre>op_cond = OperationalConditions(temperature=300, pressure=8e5)\n\nmixture_density = my_mixture.density(op_cond)\nprint(f\"{mixture_density} kg/m^3\")\n</pre>  op_cond = OperationalConditions(temperature=300, pressure=8e5)  mixture_density = my_mixture.density(op_cond) print(f\"{mixture_density} kg/m^3\") <p>We can always override the properties of the mixture by defining a new property.</p> In\u00a0[\u00a0]: Copied! <pre>my_mixture.density = lambda _: 5000.0  # Override density to be 5000 kg/m^3\noverriden_density = my_mixture.density(op_cond)\n</pre> my_mixture.density = lambda _: 5000.0  # Override density to be 5000 kg/m^3 overriden_density = my_mixture.density(op_cond) <p>We can still access the underlying materials in the mixture.</p> In\u00a0[\u00a0]: Copied! <pre>steel_density = my_mixture.mixture_fraction[0].material.density(op_cond)\nwater_density = my_mixture.mixture_fraction[1].material.density(op_cond)\nrecalculated_density = 0.7 * steel_density + 0.3 * water_density\n\nprint(f\"{steel_density=} kg/m^3\")\nprint(f\"{water_density=} kg/m^3\")\nprint(f\"{mixture_density=} kg/m^3\")\nprint(f\"{recalculated_density=} kg/m^3\")\nprint(f\"{overriden_density=} kg/m^3\")\n</pre>  steel_density = my_mixture.mixture_fraction[0].material.density(op_cond) water_density = my_mixture.mixture_fraction[1].material.density(op_cond) recalculated_density = 0.7 * steel_density + 0.3 * water_density  print(f\"{steel_density=} kg/m^3\") print(f\"{water_density=} kg/m^3\") print(f\"{mixture_density=} kg/m^3\") print(f\"{recalculated_density=} kg/m^3\") print(f\"{overriden_density=} kg/m^3\")"},{"location":"examples/mixture.ex/#material-mixtures","title":"Material Mixtures\u00b6","text":"<p>In <code>matproplib</code>, we can create a mixture of materials using the <code>Mixture</code> class. This allows us to define a material that is composed of multiple other materials, each with its own properties.</p> <p>In this example, we will create a mixture of steel and water.</p>"},{"location":"source/reference/overview/","title":"Overview","text":"<ul> <li>matproplib<ul> <li>base</li> <li>conditions</li> <li>converters<ul> <li>base</li> <li>neutronics</li> </ul> </li> <li>library<ul> <li>beryllium</li> <li>concrete</li> <li>copper</li> <li>fluids</li> <li>lithium</li> <li>polymers</li> <li>references</li> <li>steel</li> <li>superconductors</li> <li>tungsten</li> </ul> </li> <li>material</li> <li>nucleides</li> <li>properties<ul> <li>dependent</li> <li>group</li> <li>independent</li> <li>mixture</li> </ul> </li> <li>superconduction</li> <li>tools<ul> <li>neutronics</li> <li>plotting</li> <li>serialisation</li> <li>tools</li> </ul> </li> </ul> </li> </ul>"},{"location":"source/reference/matproplib/base/","title":"base","text":"<p>Base of matproplib</p>"},{"location":"source/reference/matproplib/base/#matproplib.base.ureg","title":"<code>ureg = MaterialUnitRegistry()</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/base/#matproplib.base.N_AVOGADRO","title":"<code>N_AVOGADRO = ureg.Quantity('avogadro_number').to_base_units().magnitude</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/base/#matproplib.base.ArrayFloat","title":"<code>ArrayFloat = float | int | NDArray[Shape['* x'], Number]</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/base/#matproplib.base.SuperconductingParameterisationT_co","title":"<code>SuperconductingParameterisationT_co = TypeVar('SuperconductingParameterisationT_co', bound=SuperconductingParameterisation, covariant=True, default=UndefinedSuperconductingParameterisation)</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/base/#matproplib.base.MaterialUnitRegistry","title":"<code>MaterialUnitRegistry</code>","text":"<p>               Bases: <code>UnitRegistry</code></p> <p>Physical Materials unit registry</p> Source code in <code>matproplib/base.py</code> <pre><code>class MaterialUnitRegistry(UnitRegistry):\n    \"\"\"Physical Materials unit registry\"\"\"\n\n    def __init__(self):\n        super().__init__(fmt_locale=\"en_gb\", autoconvert_offset_to_baseunit=True)\n        self.define(\"displacements_per_atom = count = dpa\")\n</code></pre>"},{"location":"source/reference/matproplib/base/#matproplib.base.References","title":"<code>References</code>","text":"<p>               Bases: <code>RootModel</code></p> <p>Reference collection model</p> Source code in <code>matproplib/base.py</code> <pre><code>class References(RootModel):\n    \"\"\"Reference collection model\"\"\"\n\n    root: dict[str | float, Reference]\n\n    @model_validator(mode=\"before\")\n    def _list_to_dict(self):\n        if isinstance(self, list):\n            return {\n                r.id if isinstance(r, Reference) else r[\"id\"]: Reference.model_validate(\n                    r\n                )\n                for r in self\n            }\n        if \"id\" in self:\n            return {self[\"id\"]: self}\n\n        if hasattr(self, \"type\"):\n            return {self.id: self}\n        return self\n\n    def __iter__(self):  # noqa: D105\n        return iter(self.root.items())\n\n    def __getitem__(self, item):  # noqa: D105\n        return self.root[item]\n\n    def __str__(self) -&gt; str:  # noqa: D105\n        return \" \".join(f\"[{k}] {ref.__str__()}\" for k, ref in self.root.items())\n\n    def combine(self, reference: References | Reference):\n        \"\"\"Combine references into this reference object\"\"\"\n        if isinstance(reference, References):\n            for k, r in reference:\n                self.root[k] = r\n        if isinstance(reference, Reference):\n            self.root[reference.id] = reference\n</code></pre>"},{"location":"source/reference/matproplib/base/#matproplib.base.References.root","title":"<code>root</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/base/#matproplib.base.References.combine","title":"<code>combine(reference)</code>","text":"<p>Combine references into this reference object</p> Source code in <code>matproplib/base.py</code> <pre><code>def combine(self, reference: References | Reference):\n    \"\"\"Combine references into this reference object\"\"\"\n    if isinstance(reference, References):\n        for k, r in reference:\n            self.root[k] = r\n    if isinstance(reference, Reference):\n        self.root[reference.id] = reference\n</code></pre>"},{"location":"source/reference/matproplib/base/#matproplib.base.PMBaseModel","title":"<code>PMBaseModel</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>ABC</code></p> <p>Base model for physical_material</p> Source code in <code>matproplib/base.py</code> <pre><code>class PMBaseModel(BaseModel, ABC):\n    \"\"\"Base model for physical_material\"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n    reference: References | None = None\n\n    def _fields(self):\n        base_field_names = PMBaseModel.model_fields.keys()\n        return dict(\n            filter(\n                lambda pair: pair[0] not in base_field_names, dict(iter(self)).items()\n            )\n        )\n\n    def __iter__(self) -&gt; Generator[tuple[str, Any], None, None]:\n        \"\"\"Iteration for Base model ignoring 'reference'\n\n        Yields\n        ------\n        :\n            field name\n        :\n            field value\n        \"\"\"\n        yield from [\n            (k, v)\n            for (k, v) in self.__dict__.items()\n            if not k.startswith(\"_\") and k != \"reference\"\n        ]\n        extra = self.__pydantic_extra__\n        if extra and extra.get(\"__pydantic_extra__\", None) != {}:\n            yield from extra.items()\n\n    def __dir__(self) -&gt; set[str]:\n        \"\"\"List methods only if they dont exist in pydantic basemodel\n\n        Returns\n        -------\n        :\n            subset of attributes\n        \"\"\"\n        return set(super().__dir__()).difference(dir(BaseModel))\n</code></pre>"},{"location":"source/reference/matproplib/base/#matproplib.base.PMBaseModel.model_config","title":"<code>model_config = ConfigDict(arbitrary_types_allowed=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/base/#matproplib.base.PMBaseModel.reference","title":"<code>reference = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/base/#matproplib.base.MaterialBaseModel","title":"<code>MaterialBaseModel</code>","text":"<p>               Bases: <code>PMBaseModel</code>, <code>ABC</code></p> Source code in <code>matproplib/base.py</code> <pre><code>class MaterialBaseModel(PMBaseModel, ABC):\n    @model_validator(mode=\"after\")\n    def _inject_group(self):\n        from matproplib.properties.dependent import (  # noqa: PLC0415\n            DependentPhysicalProperty,\n            _NoDependence,\n            _WrapCallable,\n        )\n\n        for prop in filter(\n            lambda x: not x.startswith(\"_\"), set(dir(self)).difference(dir(BaseGroup))\n        ):\n            attr = getattr(self, prop)\n            if (\n                isinstance(attr, DependentPhysicalProperty)\n                and attr.value is not None\n                and not isinstance(attr.value, _NoDependence)\n            ):\n                if (\n                    isinstance(attr.value, partial)\n                    and not isinstance(attr.value.args[0], type(self))\n                    and isinstance(self, type(self))\n                ):\n                    object.__setattr__(attr, \"value\", partial(attr.value.func, self))  # noqa: PLC2801\n                elif isinstance(attr.value, _WrapCallable) and _injection_check(\n                    attr.value.value\n                ):\n                    object.__setattr__(  # noqa: PLC2801\n                        attr.value, \"value\", partial(attr.value.value, self)\n                    )\n                elif _injection_check(attr.value):\n                    object.__setattr__(attr, \"value\", partial(attr.value, self))  # noqa: PLC2801\n        return self\n</code></pre>"},{"location":"source/reference/matproplib/base/#matproplib.base.BasePhysicalProperty","title":"<code>BasePhysicalProperty</code>","text":"<p>               Bases: <code>PMBaseModel</code>, <code>ABC</code></p> <p>Physical properties of a material</p> Source code in <code>matproplib/base.py</code> <pre><code>class BasePhysicalProperty(PMBaseModel, ABC):\n    \"\"\"Physical properties of a material\"\"\"\n\n    value: ArrayFloat\n    unit: Unit | str\n\n    model_config = ConfigDict(frozen=True)\n\n    @field_validator(\"value\", mode=\"before\")\n    @staticmethod\n    def array_validation(value):\n        \"\"\"Flatten extra array dimensions\n\n        Returns\n        -------\n        :\n            modified value\n        \"\"\"\n        if isinstance(value, np.ndarray):\n            return np.squeeze(value)\n        return value\n\n    def _unitify(self) -&gt; Quantity:\n        dunit = type(self).model_fields[\"unit\"].default\n        if isinstance(dunit, Unit) and self.unit == dunit:\n            return None\n        if isinstance(dunit, PydanticUndefinedType):\n            raise NotImplementedError(\"default unit must be provided on class\")\n        if isinstance(dunit, Unit):\n            dmag = 1\n            default = dunit\n        else:\n            default = (\n                ureg.Quantity(dunit or \"dimensionless\")\n                if isinstance(dunit, str)\n                else ureg.Quantity(1, dunit)\n            )\n            dmag = default.magnitude\n            default = default.units\n        if not (dmag == 1 or np.isclose(dmag, 1)):\n            log.debug(\n                f\"default unit for {type(self).__name__} has multiplier.\"\n                f\" Return value will converted to {default: ~P}\"\n            )\n        if self.unit == \"\":  # noqa: PLC1901\n            return ureg.Quantity(1, self.unit), default\n        if isinstance(self.unit, str) and self.unit[0].isdigit():\n            return ureg.Quantity(f\"{self.unit}\"), default\n        return ureg.Quantity(1, self.unit), default\n\n    @field_serializer(\"unit\")\n    @staticmethod\n    def serialise_unit(unit: Unit) -&gt; str:\n        \"\"\"\n        Returns\n        -------\n        :\n            Serialised a unit\n        \"\"\"\n        return f\"{unit:~P}\"\n\n    def __hash__(self):\n        \"\"\"\n        Returns\n        -------\n        :\n            hash of object\n        \"\"\"\n        return hash((type(self).name, self.value, self.unit))\n</code></pre>"},{"location":"source/reference/matproplib/base/#matproplib.base.BasePhysicalProperty.value","title":"<code>value</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/base/#matproplib.base.BasePhysicalProperty.unit","title":"<code>unit</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/base/#matproplib.base.BasePhysicalProperty.model_config","title":"<code>model_config = ConfigDict(frozen=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/base/#matproplib.base.BasePhysicalProperty.array_validation","title":"<code>array_validation(value)</code>  <code>staticmethod</code>","text":"<p>Flatten extra array dimensions</p> <p>Returns:</p> Type Description <p>modified value</p> Source code in <code>matproplib/base.py</code> <pre><code>@field_validator(\"value\", mode=\"before\")\n@staticmethod\ndef array_validation(value):\n    \"\"\"Flatten extra array dimensions\n\n    Returns\n    -------\n    :\n        modified value\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        return np.squeeze(value)\n    return value\n</code></pre>"},{"location":"source/reference/matproplib/base/#matproplib.base.BasePhysicalProperty.serialise_unit","title":"<code>serialise_unit(unit)</code>  <code>staticmethod</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>Serialised a unit</p> Source code in <code>matproplib/base.py</code> <pre><code>@field_serializer(\"unit\")\n@staticmethod\ndef serialise_unit(unit: Unit) -&gt; str:\n    \"\"\"\n    Returns\n    -------\n    :\n        Serialised a unit\n    \"\"\"\n    return f\"{unit:~P}\"\n</code></pre>"},{"location":"source/reference/matproplib/base/#matproplib.base.BaseGroup","title":"<code>BaseGroup</code>","text":"<p>               Bases: <code>MaterialBaseModel</code></p> <p>Base properties grouping class</p> Source code in <code>matproplib/base.py</code> <pre><code>class BaseGroup(MaterialBaseModel):\n    \"\"\"Base properties grouping class\"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True, validate_assignment=True)\n\n    def list(self, *, include_undefined: bool | None = False) -&gt; list[str]:\n        \"\"\"\n        Returns\n        -------\n        :\n            List of defined properties\n        \"\"\"\n        from matproplib.properties.dependent import (  # noqa: PLC0415\n            UndefinedProperty,\n        )\n\n        statement = (\n            (lambda _v: True)\n            if include_undefined is True\n            else (lambda v: not isinstance(v, UndefinedProperty))\n            if include_undefined is False\n            else (lambda v: isinstance(v, UndefinedProperty))\n        )\n        return [k for k, v in self if statement(v)]\n</code></pre>"},{"location":"source/reference/matproplib/base/#matproplib.base.BaseGroup.model_config","title":"<code>model_config = ConfigDict(arbitrary_types_allowed=True, validate_assignment=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/base/#matproplib.base.BaseGroup.list","title":"<code>list(*, include_undefined=False)</code>","text":"<p>Returns:</p> Type Description <code>list[str]</code> <p>List of defined properties</p> Source code in <code>matproplib/base.py</code> <pre><code>def list(self, *, include_undefined: bool | None = False) -&gt; list[str]:\n    \"\"\"\n    Returns\n    -------\n    :\n        List of defined properties\n    \"\"\"\n    from matproplib.properties.dependent import (  # noqa: PLC0415\n        UndefinedProperty,\n    )\n\n    statement = (\n        (lambda _v: True)\n        if include_undefined is True\n        else (lambda v: not isinstance(v, UndefinedProperty))\n        if include_undefined is False\n        else (lambda v: isinstance(v, UndefinedProperty))\n    )\n    return [k for k, v in self if statement(v)]\n</code></pre>"},{"location":"source/reference/matproplib/base/#matproplib.base.SuperconductingParameterisation","title":"<code>SuperconductingParameterisation</code>","text":"<p>               Bases: <code>BaseGroup</code></p> <p>Superconducting Parameterisation base model</p> Source code in <code>matproplib/base.py</code> <pre><code>class SuperconductingParameterisation(BaseGroup):\n    \"\"\"Superconducting Parameterisation base model\"\"\"\n\n    name: ClassVar[Literal[\"base\"]] = \"base\"\n</code></pre>"},{"location":"source/reference/matproplib/base/#matproplib.base.SuperconductingParameterisation.name","title":"<code>name = 'base'</code>  <code>class-attribute</code>","text":""},{"location":"source/reference/matproplib/base/#matproplib.base.UndefinedSuperconductingParameterisation","title":"<code>UndefinedSuperconductingParameterisation</code>","text":"<p>               Bases: <code>SuperconductingParameterisation</code></p> <p>Undefined Superconducting Parameterisation base model</p> Source code in <code>matproplib/base.py</code> <pre><code>class UndefinedSuperconductingParameterisation(SuperconductingParameterisation):\n    \"\"\"Undefined Superconducting Parameterisation base model\"\"\"\n\n    name: ClassVar[Literal[\"undef\"]] = \"undef\"\n</code></pre>"},{"location":"source/reference/matproplib/base/#matproplib.base.UndefinedSuperconductingParameterisation.name","title":"<code>name = 'undef'</code>  <code>class-attribute</code>","text":""},{"location":"source/reference/matproplib/base/#matproplib.base.unit_conversion","title":"<code>unit_conversion(unitval, default)</code>","text":"<p>Convertion of a unit wrapping pint</p> <p>Returns:</p> Type Description <code>float</code> <p>the converted value</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Failed unit conversion</p> Source code in <code>matproplib/base.py</code> <pre><code>def unit_conversion(unitval: str | Quantity | Unit, default: str) -&gt; float:\n    \"\"\"Convertion of a unit wrapping pint\n\n    Returns\n    -------\n    :\n        the converted value\n\n    Raises\n    ------\n    ValueError\n        Failed unit conversion\n    \"\"\"\n    try:\n        return ureg.Quantity(unitval).to(default).magnitude\n    except DimensionalityError as de:\n        raise ValueError(\n            f\"Cannot convert from '{de.args[0]}' \"\n            f\"({de.args[2]}) to '{de.args[1]}' ({de.args[3]})\"\n        ) from None\n</code></pre>"},{"location":"source/reference/matproplib/base/#matproplib.base.rebuild","title":"<code>rebuild(cls)</code>","text":"<p>Function to rebuild pydantic model to allow decorated creation of submodels</p> <p>Returns:</p> Type Description <p>modified class</p> Source code in <code>matproplib/base.py</code> <pre><code>def rebuild(cls):\n    \"\"\"Function to rebuild pydantic model to allow decorated creation of submodels\n\n    Returns\n    -------\n    :\n        modified class\n    \"\"\"\n    from matproplib.properties.dependent import (  # noqa: PLC0415\n        DependentPhysicalProperty,\n    )\n\n    extras = {}\n    methods = {\"__module__\": cls.__module__}\n    fields = cls.model_fields\n    for prop in set(dir(cls)).difference(\n        reduce(operator.iadd, [dir(c) for c in cls.__bases__], [])\n    ):\n        extra = getattr(cls, prop)\n        if isinstance(extra, DependentPhysicalProperty):\n            extras[prop] = (type(extra), Field(default=extra, validate_default=True))\n        else:\n            methods[prop] = extra\n\n    props = fields.pop(\"properties\", None)\n\n    mf = {\n        k: (\n            v.annotation,\n            Field(\n                default=v.default,\n                default_factory=v.default_factory,\n                validate_default=v.validate_default,\n            ),\n        )\n        for k, v in fields.items()\n    }\n\n    if props is not None:\n        if isinstance(props, FieldInfo):\n            for k, v in props.default_factory.model_fields.items():\n                if k != \"reference\":\n                    mf[k] = (\n                        v.annotation,\n                        Field(\n                            default=v.default,\n                            default_factory=v.default_factory,\n                            validate_default=v.validate_default,\n                        ),\n                    )\n        else:\n            raise NotImplementedError\n\n    model = create_model(\n        cls.__name__,\n        __base__=type(\"_DynamicParent\", cls.__bases__, methods),\n        **mf,\n        **extras,\n    )\n    return cls_vars(model, cls, methods)\n</code></pre>"},{"location":"source/reference/matproplib/base/#matproplib.base.cls_vars","title":"<code>cls_vars(model, orig_cls, methods)</code>","text":"Source code in <code>matproplib/base.py</code> <pre><code>def cls_vars(model, orig_cls, methods):\n    classvars = {cv: getattr(orig_cls, cv) for cv in methods.get(\"__class_vars__\", {})}\n    for name, val in classvars.items():\n        setattr(model, name, val)\n    return model\n</code></pre>"},{"location":"source/reference/matproplib/base/#matproplib.base.all_subclasses","title":"<code>all_subclasses(cls)</code>","text":"Source code in <code>matproplib/base.py</code> <pre><code>def all_subclasses(cls):\n    return set(cls.__subclasses__()).union([\n        s for c in cls.__subclasses__() for s in all_subclasses(c)\n    ])\n</code></pre>"},{"location":"source/reference/matproplib/conditions/","title":"conditions","text":"<p>Conditions of a Material</p>"},{"location":"source/reference/matproplib/conditions/#matproplib.conditions.DependentPropertyConditionConfigTD","title":"<code>DependentPropertyConditionConfigTD = dict[str, tuple[str, float, float] | str | Unit | tuple[str, float] | tuple[float, float]]</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/conditions/#matproplib.conditions.OpCondT","title":"<code>OpCondT = OperationalConditions | ModifiedOperationalConditions</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/conditions/#matproplib.conditions.OperationalConditions","title":"<code>OperationalConditions</code>","text":"<p>               Bases: <code>PMBaseModel</code></p> <p>Operating conditions of a given material</p> Source code in <code>matproplib/conditions.py</code> <pre><code>class OperationalConditions(PMBaseModel):\n    \"\"\"Operating conditions of a given material\"\"\"\n\n    temperature: Temperature\n    pressure: Pressure | None = None\n    magnetic_field: MagneticField | None = None\n    strain: Strain | None = None\n    neutron_damage: NeutronDamage | None = None\n    neutron_fluence: NeutronFluence | None = None\n\n    __pydantic_extra__: dict[str, PhysicalProperty] = Field(init=False)\n    model_config = ConfigDict(\n        extra=\"allow\", arbitrary_types_allowed=True, validate_assignment=True\n    )\n\n    def __str__(self) -&gt; str:  # noqa: D105\n        return f\"{type(self).__name__}({super().__str__()})\"\n\n    @model_validator(mode=\"before\")\n    def _value_only(self):\n        \"\"\"Allow value setting with default units\n\n        Returns\n        -------\n        :\n            the operating conditions instance\n        \"\"\"\n        for k, v in self.items():\n            if (\n                v is not None\n                and not isinstance(v, dict)\n                and not isinstance(v, PhysicalProperty)\n            ):\n                self[k] = {\"value\": v}\n        return self\n\n    @model_validator(mode=\"after\")\n    def _all_values_same_length(self):\n        \"\"\"Validate ther are the same number of conditions\n\n        Returns\n        -------\n        :\n            the operating conditions instance\n\n        Raises\n        ------\n        ValueError\n            If value sizes are not compatible\n        \"\"\"\n        fields = dict(iter(self))\n        values = list(fields.values())\n        if not any(not isinstance(v, np.ndarray) for v in values):\n            return self\n\n        old_length = length = (\n            values[0].value.size if isinstance(values[0].value, np.ndarray) else 1\n        )\n        for v in values[1:]:\n            if v is not None and isinstance(v.value, np.ndarray):\n                if length == 1:\n                    length = v.value.size\n                elif v.value.size != length:\n                    raise ValueError(\n                        \"All values must be of equal size or a singular value\"\n                    )\n            else:\n                old_length = 1\n\n        if old_length != length:\n            for k, v in fields.items():\n                if v is not None and (\n                    not isinstance(v.value, np.ndarray) or v.value.size == 1\n                ):\n                    val = v.value\n                    value = np.full(\n                        length, v.magnitude if isinstance(val, ureg.Quantity) else val\n                    )\n                    object.__setattr__(  # noqa: PLC2801\n                        self, k, type(v)(value=value, unit=v.unit, reference=v.reference)\n                    )\n        return self\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Make op_cond hashable\"\"\"  # noqa: DOC201\n        return hash(self.model_dump().values())\n</code></pre>"},{"location":"source/reference/matproplib/conditions/#matproplib.conditions.OperationalConditions.temperature","title":"<code>temperature</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/conditions/#matproplib.conditions.OperationalConditions.pressure","title":"<code>pressure = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/conditions/#matproplib.conditions.OperationalConditions.magnetic_field","title":"<code>magnetic_field = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/conditions/#matproplib.conditions.OperationalConditions.strain","title":"<code>strain = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/conditions/#matproplib.conditions.OperationalConditions.neutron_damage","title":"<code>neutron_damage = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/conditions/#matproplib.conditions.OperationalConditions.neutron_fluence","title":"<code>neutron_fluence = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/conditions/#matproplib.conditions.OperationalConditions.model_config","title":"<code>model_config = ConfigDict(extra='allow', arbitrary_types_allowed=True, validate_assignment=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/conditions/#matproplib.conditions.PropertyConfig","title":"<code>PropertyConfig</code>","text":"<p>               Bases: <code>PMBaseModel</code></p> <p>Configuration model found bounding properties in a given unit</p> Source code in <code>matproplib/conditions.py</code> <pre><code>class PropertyConfig(PMBaseModel):\n    \"\"\"Configuration model found bounding properties in a given unit\"\"\"\n\n    unit: Unit | str | None = None\n    lower: float | None = None\n    upper: float | None = None\n\n    @model_validator(mode=\"before\")\n    def _convert_to_structure(self):\n        if isinstance(self, str | Unit):\n            return {\"unit\": self}\n        if isinstance(self, tuple):\n            if not isinstance(self[0], str) and len(self) == 2:  # noqa: PLR2004\n                return {\"lower\": self[0], \"upper\": self[1]}\n            if len(self) == 2:  # noqa: PLR2004\n                return {\"unit\": self[0], \"lower\": self[1]}\n            if len(self) == 3:  # noqa: PLR2004\n                return {\"unit\": self[0], \"lower\": self[1], \"upper\": self[2]}\n        return self\n\n    @field_validator(\"unit\", mode=\"after\")\n    @staticmethod\n    def _unit_valid(unit):\n        return ureg.Unit(unit)\n\n    @field_serializer(\"unit\")\n    @staticmethod\n    def _serialise_unit(unit: Unit) -&gt; str:\n        \"\"\"\n        Returns\n        -------\n        :\n            Serialised a unit\n        \"\"\"\n        return f\"{unit:~P}\"\n</code></pre>"},{"location":"source/reference/matproplib/conditions/#matproplib.conditions.PropertyConfig.unit","title":"<code>unit = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/conditions/#matproplib.conditions.PropertyConfig.lower","title":"<code>lower = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/conditions/#matproplib.conditions.PropertyConfig.upper","title":"<code>upper = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/conditions/#matproplib.conditions.DependentPropertyConditionConfig","title":"<code>DependentPropertyConditionConfig</code>","text":"<p>               Bases: <code>PMBaseModel</code></p> <p>Configuration of limits of a dependent property for its operational conditions</p> Source code in <code>matproplib/conditions.py</code> <pre><code>class DependentPropertyConditionConfig(PMBaseModel):\n    \"\"\"Configuration of limits of a dependent property for its operational conditions\"\"\"\n\n    temperature: PropertyConfig = Field(default_factory=lambda: PropertyConfig(unit=\"K\"))\n    pressure: PropertyConfig = Field(default_factory=lambda: PropertyConfig(unit=\"Pa\"))\n    magnetic_field: PropertyConfig = Field(\n        default_factory=lambda: PropertyConfig(unit=\"T\")\n    )\n    strain: PropertyConfig = Field(default_factory=lambda: PropertyConfig(unit=\"\"))\n    neutron_fluence: PropertyConfig = Field(\n        default_factory=lambda: PropertyConfig(unit=\"1/m^2\")\n    )\n    neutron_damage: PropertyConfig = Field(\n        default_factory=lambda: PropertyConfig(unit=\"dpa\")\n    )\n    model_config = ConfigDict(extra=\"allow\")\n    __pydantic_extra__: dict[str, PropertyConfig] = Field(init=False)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Returns\n        -------\n        :\n            String representation\n        \"\"\"\n        cls = type(self)\n        cells = \"\".join([\n            f\"{k}={type(v).__name__}({v})\"\n            for k, v in self\n            if k not in cls.model_fields or v != cls.model_fields[k].default_factory()\n        ])\n        return f\"{cls.__name__}({cells})\"\n\n    __str__ = __repr__\n\n    @model_validator(mode=\"after\")\n    def _pass_int_default_unit(self):\n        for n, v in self:\n            if not isinstance(v, PropertyConfig):\n                v = PropertyConfig.model_validate(v)  # noqa: PLW2901\n                setattr(self, n, v)\n            if v.unit is None:\n                field = type(self).model_fields.get(n, None)\n                if field is None:\n                    raise ValueError(\"Unit required for unknown condition configuration\")\n                v.unit = field.default_factory().unit\n        return self\n\n    @model_serializer\n    def _serialise_op_cond_config(self) -&gt; dict[str, PropertyConfig]:\n        cls = type(self)\n        return {k: v for k, v in self if v != cls.model_fields[k].default_factory()}\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Make hashable\"\"\"  # noqa: DOC201\n        return hash(self.model_dump().values())\n</code></pre>"},{"location":"source/reference/matproplib/conditions/#matproplib.conditions.DependentPropertyConditionConfig.temperature","title":"<code>temperature = Field(default_factory=(lambda: PropertyConfig(unit='K')))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/conditions/#matproplib.conditions.DependentPropertyConditionConfig.pressure","title":"<code>pressure = Field(default_factory=(lambda: PropertyConfig(unit='Pa')))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/conditions/#matproplib.conditions.DependentPropertyConditionConfig.magnetic_field","title":"<code>magnetic_field = Field(default_factory=(lambda: PropertyConfig(unit='T')))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/conditions/#matproplib.conditions.DependentPropertyConditionConfig.strain","title":"<code>strain = Field(default_factory=(lambda: PropertyConfig(unit='')))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/conditions/#matproplib.conditions.DependentPropertyConditionConfig.neutron_fluence","title":"<code>neutron_fluence = Field(default_factory=(lambda: PropertyConfig(unit='1/m^2')))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/conditions/#matproplib.conditions.DependentPropertyConditionConfig.neutron_damage","title":"<code>neutron_damage = Field(default_factory=(lambda: PropertyConfig(unit='dpa')))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/conditions/#matproplib.conditions.DependentPropertyConditionConfig.model_config","title":"<code>model_config = ConfigDict(extra='allow')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/conditions/#matproplib.conditions.ModifiedOperationalConditions","title":"<code>ModifiedOperationalConditions</code>","text":"Source code in <code>matproplib/conditions.py</code> <pre><code>class ModifiedOperationalConditions:\n    def __iter__(self):\n        return iter(self.__dict__.items())\n\n    def __setattr__(self, name, value):\n        object.__setattr__(self, name, UnVerifiedPhysicalProperty(*value))\n</code></pre>"},{"location":"source/reference/matproplib/conditions/#matproplib.conditions.STPConditions","title":"<code>STPConditions</code>","text":"<p>               Bases: <code>OperationalConditions</code></p> <p>IUPAC standard temperature and pressure</p> Source code in <code>matproplib/conditions.py</code> <pre><code>class STPConditions(OperationalConditions):\n    \"\"\"IUPAC standard temperature and pressure\"\"\"\n\n    temperature: Temperature = Field(default=Temperature(value=273.15), frozen=True)\n    pressure: Pressure = Field(default=Pressure(value=100, unit=\"kPa\"), frozen=True)\n\n    @model_validator(mode=\"after\")\n    def _enforce_frozen_stp(self) -&gt; STPConditions:\n        if any(\n            getattr(self, k).value != type(self).model_fields[k].default.value\n            for k in (\"temperature\", \"pressure\")\n        ):\n            raise ValueError(\n                \"Standard temperature and pressure conditions cannot be modified\"\n            )\n        return self\n\n    def __copy__(self) -&gt; OperationalConditions:\n        \"\"\"\n        Copy a standard condition object to allow modification\n\n        Returns\n        -------\n        :\n            OperationalConditions not STPConditions\n        \"\"\"\n        md = self.model_dump()\n\n        return OperationalConditions(\n            temperature=md.pop(\"temperature\"), pressure=md.pop(\"pressure\"), **md\n        )\n</code></pre>"},{"location":"source/reference/matproplib/conditions/#matproplib.conditions.STPConditions.temperature","title":"<code>temperature = Field(default=(Temperature(value=273.15)), frozen=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/conditions/#matproplib.conditions.STPConditions.pressure","title":"<code>pressure = Field(default=(Pressure(value=100, unit='kPa')), frozen=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/conditions/#matproplib.conditions.modify_conditions","title":"<code>modify_conditions(op_cond, op_cond_config)</code>","text":"<p>Modify conditions to fit unit of condition configuration</p> <p>Returns:</p> Type Description <code>ModifiedOperationalConditions</code> <p>Modified conditions</p> Source code in <code>matproplib/conditions.py</code> <pre><code>def modify_conditions(\n    op_cond: OpCondT, op_cond_config: DependentPropertyConditionConfig\n) -&gt; ModifiedOperationalConditions:\n    \"\"\"\n    Modify conditions to fit unit of condition configuration\n\n    Returns\n    -------\n    :\n        Modified conditions\n    \"\"\"\n    mc = ModifiedOperationalConditions()\n    cond_unit_names = [c[0] for c in op_cond_config]\n    for cond_n, cond_v in op_cond:\n        if cond_v is not None:\n            new_unit = (\n                getattr(op_cond_config, cond_n).unit\n                if cond_n in cond_unit_names\n                else cond_v.unit\n            )\n            setattr(\n                mc,\n                cond_n,\n                (\n                    ureg.Quantity(cond_v.value, cond_v.unit).to(new_unit).magnitude\n                    if new_unit != cond_v.unit\n                    else cond_v.value,\n                    new_unit,\n                ),\n            )\n    return mc\n</code></pre>"},{"location":"source/reference/matproplib/conditions/#matproplib.conditions.check_conditions","title":"<code>check_conditions(op_cond, op_cond_config)</code>","text":"<p>Check condtions are within range of condition configuration</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Out of bounds</p> Source code in <code>matproplib/conditions.py</code> <pre><code>def check_conditions(\n    op_cond: ModifiedOperationalConditions,\n    op_cond_config: DependentPropertyConditionConfig,\n):\n    \"\"\"Check condtions are within range of condition configuration\n\n    Raises\n    ------\n    ValueError\n        Out of bounds\n    \"\"\"\n    empty = PropertyConfig()\n    for name, cond in op_cond:\n        cond_conf = getattr(op_cond_config, name, empty)\n        if cond_conf.lower is not None and np.less(cond, cond_conf.lower).all():\n            raise ValueError(\n                f\"Operating condition '{name}' ({_format_value(cond)}) lower\"\n                f\" than lower bound {_format_value(cond_conf.lower, cond_conf.unit)}\"\n            )\n        if cond_conf.upper is not None and np.greater(cond, cond_conf.upper).all():\n            raise ValueError(\n                f\"Operating condition '{name} ({_format_value(cond)})' higher\"\n                f\" than upper bound {_format_value(cond_conf.upper, cond_conf.unit)}\"\n            )\n</code></pre>"},{"location":"source/reference/matproplib/material/","title":"material","text":"<p>The main material objects</p>"},{"location":"source/reference/matproplib/material/#matproplib.material.BaseGroupT_co","title":"<code>BaseGroupT_co = TypeVar('BaseGroupT_co', bound=BaseGroup, covariant=True)</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/material/#matproplib.material.PropertiesT_co","title":"<code>PropertiesT_co = TypeVar('PropertiesT_co', bound=Properties, covariant=True)</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/material/#matproplib.material.Owner","title":"<code>Owner = TypeVar('Owner')</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/material/#matproplib.material.DPPT","title":"<code>DPPT = TypeVar('DPPT', bound=DependentPhysicalProperty)</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/material/#matproplib.material.MaterialFraction","title":"<code>MaterialFraction</code>","text":"<p>               Bases: <code>PMBaseModel</code>, <code>Generic[ConverterK]</code></p> <p>Material fraction object</p> Source code in <code>matproplib/material.py</code> <pre><code>class MaterialFraction(PMBaseModel, Generic[ConverterK]):\n    \"\"\"Material fraction object\"\"\"\n\n    material: Material[ConverterK]\n    fraction: NonNegativeFloat\n\n    @model_validator(mode=\"before\")\n    def _input_variation(self):\n        if isinstance(self, tuple):\n            return {\"material\": self[0], \"fraction\": self[1]}\n        return self\n</code></pre>"},{"location":"source/reference/matproplib/material/#matproplib.material.MaterialFraction.material","title":"<code>material</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/material/#matproplib.material.MaterialFraction.fraction","title":"<code>fraction</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/material/#matproplib.material.Material","title":"<code>Material</code>","text":"<p>               Bases: <code>MaterialBaseModel</code>, <code>ABC</code>, <code>Generic[ConverterK]</code></p> <p>The Material Class, container for all attributes of a material</p> Source code in <code>matproplib/material.py</code> <pre><code>class Material(MaterialBaseModel, ABC, Generic[ConverterK]):\n    \"\"\"The Material Class, container for all attributes of a material\"\"\"\n\n    model_config = ConfigDict(\n        arbitrary_types_allowed=True, validate_assignment=True, validate_default=True\n    )\n    name: str\n    elements: Elements = Field(\n        default=[], validation_alias=AliasChoices(\"elements\", \"chemical_equation\")\n    )\n    converters: Converters[ConverterK] = Field(default_factory=Converters)\n    reference: References | None = None\n    mixture_fraction: list[MaterialFraction[ConverterK]] | None = Field(\n        default=None, frozen=True\n    )\n\n    def __init__(self, **kwargs):\n        if type(self) is Material:\n            raise NotImplementedError(\n                \"Cannot initialise Material directly please use the 'material' function\"\n            )\n        super().__init__(**kwargs)\n\n    @model_validator(mode=\"after\")\n    def _mixture_validation(self):\n        if self.mixture_fraction is None:\n            return self\n\n        def_props = set(self.mixture_fraction[0].material.list_properties())\n        for mf in self.mixture_fraction[1:]:\n            if diff := def_props.symmetric_difference(mf.material.list_properties()):\n                for dp in diff:\n                    if (\n                        hasattr(self, dp)\n                        and isinstance(\n                            getattr(self, dp),\n                            UndefinedProperty | UndefinedSuperconductingParameterisation,\n                        )\n                    ) or not hasattr(self, dp):\n                        material = (\n                            self.mixture_fraction[0].material\n                            if dp not in def_props\n                            else mf.material\n                        )\n                        msg = f\"{dp} is undefined on {material}\"\n                        log.debug(msg)\n                        object.__setattr__(self, dp, AttributeErrorProperty(msg=msg))  # noqa: PLC2801\n\n        return self\n\n    def convert(self, name: ConverterK, op_cond: OpCondT, *args, **kwargs):\n        \"\"\"Convert material to another format\"\"\"  # noqa: DOC201\n        return self.converters[name].convert(\n            self, OperationalConditions.model_validate(op_cond), *args, **kwargs\n        )\n\n    @property\n    def is_superconductor(self):\n        \"\"\"Does the material have any superconducting parameterisation\"\"\"\n        return hasattr(self, \"critical_current_density\")\n\n    def __getattr__(self, value: str) -&gt; Any:\n        \"\"\"Override attribute access for shorthand to nested attributes\"\"\"  # noqa: DOC201\n        try:\n            if value != \"superconducting_parameterisation\" and hasattr(\n                self.superconducting_parameterisation, value\n            ):\n                return getattr(self.superconducting_parameterisation, value)\n        except AttributeError:\n            pass\n        return super().__getattr__(value)\n\n    def __str__(self) -&gt; str:  # noqa: D105\n        undefined = (\n            f\", undefined_properties={ulp}\"\n            if (ulp := self.list_properties(include_undefined=None))\n            else \"\"\n        )\n        p = f\", properties={lp}{undefined})\" if (lp := self.list_properties()) else \"\"\n        c = f\", {self.converters.__repr__()}\" if len(self.converters.root) &gt; 0 else \"\"\n        return f\"{type(self).__name__}(elements={self.elements.__repr__()}{p}{c})\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Avoid nested reproduction for partial values\"\"\"  # noqa: DOC201\n        p = \"\"\n        for k in self.list_properties(include_undefined=True):\n            v = getattr(self, k)\n            if isinstance(v.value, partial):\n                start, end_ = repr(v).split(\"value\", 1)\n                end = end_.rsplit(\"unit\", 1)[-1]\n                out = repr(v.value)\n\n                if out != \"...\":\n                    out = f\"{out.split('&gt;')[0]}&gt;)\"\n                p += f\", {k}={type(v).__name__}({start}value={out}, unit{end})\"\n            else:\n                p += f\", {k}={v}\"\n        return (\n            f\"{type(self).__name__}(reference={self.reference},\"\n            f\" elements={self.elements.__repr__()}, {self.converters.__repr__()}{p})\"\n        )\n\n    def list_properties(self, *, include_undefined: bool | None = False) -&gt; list[str]:\n        \"\"\"\n        Returns\n        -------\n        :\n            List of defined properties\n        \"\"\"\n        from matproplib.properties.dependent import (  # noqa: PLC0415\n            UndefinedProperty,\n        )\n\n        statement = (\n            (lambda _v: True)\n            if include_undefined is True\n            else (lambda v: not isinstance(v, UndefinedProperty))\n            if include_undefined is False\n            else (lambda v: isinstance(v, UndefinedProperty))\n        )\n        return [\n            k\n            for k, v in self\n            if statement(v) and isinstance(v, DependentPhysicalProperty)\n        ]\n</code></pre>"},{"location":"source/reference/matproplib/material/#matproplib.material.Material.model_config","title":"<code>model_config = ConfigDict(arbitrary_types_allowed=True, validate_assignment=True, validate_default=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/material/#matproplib.material.Material.name","title":"<code>name</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/material/#matproplib.material.Material.elements","title":"<code>elements = Field(default=[], validation_alias=(AliasChoices('elements', 'chemical_equation')))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/material/#matproplib.material.Material.converters","title":"<code>converters = Field(default_factory=Converters)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/material/#matproplib.material.Material.reference","title":"<code>reference = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/material/#matproplib.material.Material.mixture_fraction","title":"<code>mixture_fraction = Field(default=None, frozen=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/material/#matproplib.material.Material.is_superconductor","title":"<code>is_superconductor</code>  <code>property</code>","text":"<p>Does the material have any superconducting parameterisation</p>"},{"location":"source/reference/matproplib/material/#matproplib.material.Material.convert","title":"<code>convert(name, op_cond, *args, **kwargs)</code>","text":"<p>Convert material to another format</p> Source code in <code>matproplib/material.py</code> <pre><code>def convert(self, name: ConverterK, op_cond: OpCondT, *args, **kwargs):\n    \"\"\"Convert material to another format\"\"\"  # noqa: DOC201\n    return self.converters[name].convert(\n        self, OperationalConditions.model_validate(op_cond), *args, **kwargs\n    )\n</code></pre>"},{"location":"source/reference/matproplib/material/#matproplib.material.Material.list_properties","title":"<code>list_properties(*, include_undefined=False)</code>","text":"<p>Returns:</p> Type Description <code>list[str]</code> <p>List of defined properties</p> Source code in <code>matproplib/material.py</code> <pre><code>def list_properties(self, *, include_undefined: bool | None = False) -&gt; list[str]:\n    \"\"\"\n    Returns\n    -------\n    :\n        List of defined properties\n    \"\"\"\n    from matproplib.properties.dependent import (  # noqa: PLC0415\n        UndefinedProperty,\n    )\n\n    statement = (\n        (lambda _v: True)\n        if include_undefined is True\n        else (lambda v: not isinstance(v, UndefinedProperty))\n        if include_undefined is False\n        else (lambda v: isinstance(v, UndefinedProperty))\n    )\n    return [\n        k\n        for k, v in self\n        if statement(v) and isinstance(v, DependentPhysicalProperty)\n    ]\n</code></pre>"},{"location":"source/reference/matproplib/material/#matproplib.material.FullMaterial","title":"<code>FullMaterial</code>","text":"<p>               Bases: <code>Material[ConverterK]</code>, <code>Generic[ConverterK, SuperconductingParameterisationT_co]</code></p> <p>Fully specified material with all default properties</p> Source code in <code>matproplib/material.py</code> <pre><code>class FullMaterial(\n    Material[ConverterK], Generic[ConverterK, SuperconductingParameterisationT_co]\n):\n    \"\"\"Fully specified material with all default properties\"\"\"\n\n    density: UndefinedProperty | Density = field_alias_path(\"density\", \"properties\")\n\n    poissons_ratio: UndefinedProperty | PoissonsRatio = field_alias_path(\n        \"poissons_ratio\", \"properties\"\n    )\n    residual_resistance_ratio: UndefinedProperty | ResidualResistanceRatio = (\n        field_alias_path(\"residual_resistance_ratio\", \"properties\")\n    )\n    thermal_conductivity: UndefinedProperty | ThermalConductivity = field_alias_path(\n        \"thermal_conductivity\", \"properties\"\n    )\n    youngs_modulus: UndefinedProperty | YoungsModulus = field_alias_path(\n        \"youngs_modulus\", \"properties\"\n    )\n    shear_modulus: UndefinedProperty | ShearModulus = field_alias_path(\n        \"shear_modulus\", \"properties\"\n    )\n    bulk_modulus: UndefinedProperty | BulkModulus = field_alias_path(\n        \"bulk_modulus\", \"properties\"\n    )\n    coefficient_thermal_expansion: UndefinedProperty | CoefficientThermalExpansion = (\n        field_alias_path(\"coefficient_thermal_expansion\", \"properties\")\n    )\n    specific_heat_capacity: UndefinedProperty | SpecificHeatCapacity = field_alias_path(\n        \"specific_heat_capacity\", \"properties\"\n    )\n    electrical_resistivity: UndefinedProperty | ElectricalResistivity = field_alias_path(\n        \"electrical_resistivity\", \"properties\"\n    )\n    magnetic_saturation: UndefinedProperty | MagneticSaturation = field_alias_path(\n        \"magnetic_saturation\", \"properties\"\n    )\n    magnetic_susceptibility: UndefinedProperty | MagneticSusceptibility = (\n        field_alias_path(\"magnetic_susceptibility\", \"properties\")\n    )\n    viscous_remanent_magnetisation: UndefinedProperty | ViscousRemanentMagnetism = (\n        field_alias_path(\"viscous_remanent_magnetisation\", \"properties\")\n    )\n    coercive_field: UndefinedProperty | CoerciveField = field_alias_path(\n        \"coercive_field\", \"properties\"\n    )\n    minimum_yield_stress: UndefinedProperty | YieldStress = field_alias_path(\n        \"minimum_yield_stress\", \"properties\"\n    )\n    average_yield_stress: UndefinedProperty | YieldStress = field_alias_path(\n        \"average_yield_stress\", \"properties\"\n    )\n    minimum_ultimate_tensile_stress: UndefinedProperty | TensileStress = (\n        field_alias_path(\"minimum_ultimate_tensile_stress\", \"properties\")\n    )\n    average_ultimate_tensile_stress: UndefinedProperty | TensileStress = (\n        field_alias_path(\"average_ultimate_tensile_stress\", \"properties\")\n    )\n    superconducting_parameterisation: SerializeAsAny[\n        SuperconductingParameterisationT_co\n    ] = field_alias_path(\n        \"superconducting_parameterisation\",\n        \"properties\",\n        default=UndefinedSuperconductingParameterisation(),\n    )\n\n    field_validator(\"superconducting_parameterisation\", mode=\"before\")(\n        _superconduction_validation\n    )\n\n    @model_validator(mode=\"before\")\n    def _properties_validation(self):\n        if \"properties\" in self and isinstance(self[\"properties\"], dict):\n            self[\"properties\"] = props(**self[\"properties\"])\n        return self\n</code></pre>"},{"location":"source/reference/matproplib/material/#matproplib.material.FullMaterial.density","title":"<code>density = field_alias_path('density', 'properties')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/material/#matproplib.material.FullMaterial.poissons_ratio","title":"<code>poissons_ratio = field_alias_path('poissons_ratio', 'properties')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/material/#matproplib.material.FullMaterial.residual_resistance_ratio","title":"<code>residual_resistance_ratio = field_alias_path('residual_resistance_ratio', 'properties')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/material/#matproplib.material.FullMaterial.thermal_conductivity","title":"<code>thermal_conductivity = field_alias_path('thermal_conductivity', 'properties')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/material/#matproplib.material.FullMaterial.youngs_modulus","title":"<code>youngs_modulus = field_alias_path('youngs_modulus', 'properties')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/material/#matproplib.material.FullMaterial.shear_modulus","title":"<code>shear_modulus = field_alias_path('shear_modulus', 'properties')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/material/#matproplib.material.FullMaterial.bulk_modulus","title":"<code>bulk_modulus = field_alias_path('bulk_modulus', 'properties')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/material/#matproplib.material.FullMaterial.coefficient_thermal_expansion","title":"<code>coefficient_thermal_expansion = field_alias_path('coefficient_thermal_expansion', 'properties')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/material/#matproplib.material.FullMaterial.specific_heat_capacity","title":"<code>specific_heat_capacity = field_alias_path('specific_heat_capacity', 'properties')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/material/#matproplib.material.FullMaterial.electrical_resistivity","title":"<code>electrical_resistivity = field_alias_path('electrical_resistivity', 'properties')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/material/#matproplib.material.FullMaterial.magnetic_saturation","title":"<code>magnetic_saturation = field_alias_path('magnetic_saturation', 'properties')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/material/#matproplib.material.FullMaterial.magnetic_susceptibility","title":"<code>magnetic_susceptibility = field_alias_path('magnetic_susceptibility', 'properties')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/material/#matproplib.material.FullMaterial.viscous_remanent_magnetisation","title":"<code>viscous_remanent_magnetisation = field_alias_path('viscous_remanent_magnetisation', 'properties')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/material/#matproplib.material.FullMaterial.coercive_field","title":"<code>coercive_field = field_alias_path('coercive_field', 'properties')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/material/#matproplib.material.FullMaterial.minimum_yield_stress","title":"<code>minimum_yield_stress = field_alias_path('minimum_yield_stress', 'properties')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/material/#matproplib.material.FullMaterial.average_yield_stress","title":"<code>average_yield_stress = field_alias_path('average_yield_stress', 'properties')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/material/#matproplib.material.FullMaterial.minimum_ultimate_tensile_stress","title":"<code>minimum_ultimate_tensile_stress = field_alias_path('minimum_ultimate_tensile_stress', 'properties')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/material/#matproplib.material.FullMaterial.average_ultimate_tensile_stress","title":"<code>average_ultimate_tensile_stress = field_alias_path('average_ultimate_tensile_stress', 'properties')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/material/#matproplib.material.FullMaterial.superconducting_parameterisation","title":"<code>superconducting_parameterisation = field_alias_path('superconducting_parameterisation', 'properties', default=(UndefinedSuperconductingParameterisation()))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/material/#matproplib.material.AttributeErrorSCParameterisation","title":"<code>AttributeErrorSCParameterisation</code>","text":"<p>               Bases: <code>UndefinedSuperconductingParameterisation</code></p> <p>Attribute Error superconducting parameterisation</p> Source code in <code>matproplib/material.py</code> <pre><code>class AttributeErrorSCParameterisation(UndefinedSuperconductingParameterisation):\n    \"\"\"Attribute Error superconducting parameterisation\"\"\"\n\n    critical_current_density: AttributeErrorProperty\n</code></pre>"},{"location":"source/reference/matproplib/material/#matproplib.material.AttributeErrorSCParameterisation.critical_current_density","title":"<code>critical_current_density</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/material/#matproplib.material.DPPWrap","title":"<code>DPPWrap</code>","text":"<p>               Bases: <code>Protocol</code>, <code>Generic[Owner]</code></p> <p>Dependent Property wrapper protocol</p> Source code in <code>matproplib/material.py</code> <pre><code>class DPPWrap(Protocol, Generic[Owner]):\n    \"\"\"Dependent Property wrapper protocol\"\"\"\n\n    def __get__(  # noqa: D105, PLE0302\n        _self,  # noqa: N805\n        inst: object,\n        owner: type[Owner],\n        name: str,\n    ) -&gt; DependentPhysicalProperty: ...\n</code></pre>"},{"location":"source/reference/matproplib/material/#matproplib.material.field_alias_path","title":"<code>field_alias_path(name, *alias_path, default=None)</code>","text":"<p>Helper to create alias field for properties</p> Source code in <code>matproplib/material.py</code> <pre><code>def field_alias_path(name, *alias_path, default=None):\n    \"\"\"Helper to create alias field for properties\"\"\"  # noqa: DOC201\n    return Field(\n        default=default or UndefinedProperty(),\n        validation_alias=AliasChoices(name, AliasPath(*alias_path, name)),\n    )\n</code></pre>"},{"location":"source/reference/matproplib/material/#matproplib.material.material","title":"<code>material(name, elements=None, properties=None, converters=None, reference=None, **custom_properties)</code>","text":"<p>Functional material definition</p> <p>Returns:</p> Type Description <code>type[Material[ConverterK]]</code> <p>New material class</p> Source code in <code>matproplib/material.py</code> <pre><code>def material(  # noqa: C901\n    name: str,\n    elements: Elements\n    | str\n    | list[str | ElementFraction]\n    | list[str]\n    | ElementsTD\n    | None = None,\n    properties: Properties\n    | dict[str, Ldefine | DependentPhysicalProperty]\n    | None = None,\n    converters: Converter | Iterable[Converter] | Converters[ConverterK] | None = None,\n    reference: References | None = None,\n    **custom_properties: DependentPhysicalProperty,\n) -&gt; type[Material[ConverterK]]:\n    \"\"\"Functional material definition\n\n    Returns\n    -------\n    :\n        New material class\n    \"\"\"\n    from matproplib.properties.dependent import (  # noqa: PLC0415\n        DependentPhysicalProperty,\n    )\n\n    def combine_refs(ref1: References | None, ref2: FieldInfo) -&gt; References | None:\n        if ref2.default is not None:\n            if ref1 is not None:\n                return References.model_validate(ref1).combine(ref2.default)\n            return ref2.default\n        return None\n\n    if properties is None:\n        properties: Properties = Properties()\n\n    if type(properties) is Properties:\n        props_ = {}\n    elif isinstance(properties, dict):\n        props_ = props(as_field=properties.pop(\"as_field\", True), **properties)\n    elif isinstance(properties, FieldInfo):\n        props_ = properties\n    elif isinstance(properties, Properties):\n        props_ = copy.deepcopy(type(properties).model_fields)\n        vals = properties.list()\n        for k in vals:\n            props_[k].default = getattr(properties, k)\n        if properties.reference is not None:\n            props_[\"reference\"].default = properties.reference\n        reference = combine_refs(reference, props_.pop(\"reference\"))\n    else:\n        raise NotImplementedError\n\n    if isinstance(props_, FieldInfo):\n        props_ = copy.deepcopy(props_.default_factory.model_fields)\n        reference = combine_refs(reference, props_.pop(\"reference\"))\n\n    if \"superconducting_parameterisation\" in props_:\n        p = props_[\"superconducting_parameterisation\"].annotation\n        props_[\"superconducting_parameterisation\"].annotation = SerializeAsAny[p]\n\n    return create_model(\n        name,\n        __base__=Material[ConverterK],\n        name=(str, name),\n        elements=(\n            Elements,\n            [] if elements is None else elements,\n        ),\n        converters=(Converters, converters or {}),\n        reference=(References | None, reference),\n        **{\n            c: (\n                DependentPhysicalProperty,\n                Field(default_factory=lambda v=v: v),\n            )\n            for c, v in custom_properties.items()\n        },\n        **{\n            k: (\n                v.annotation,\n                Field(default_factory=lambda v=v.default: v),\n            )\n            for k, v in props_.items()\n        },\n    )\n</code></pre>"},{"location":"source/reference/matproplib/material/#matproplib.material.mixture","title":"<code>mixture(name, materials, fraction_type='atomic', converters=None, reference=None, *, mix_condition=None, **property_overrides)</code>","text":"<p>Create a mixture from a set of materials</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Mixture name</p> required <code>materials</code> <code>Sequence[MaterialFraction[ConverterK] | tuple[Material[ConverterK], float]]</code> <p>list of materials with their fractions</p> required <code>fraction_type</code> <code>Literal['atomic', 'mass', 'volume']</code> <p>the type of fractional mixing to perform</p> <code>'atomic'</code> <code>converters</code> <code>Converters[ConverterK] | None</code> <p>Conversion to other formats, these are not transferred from constituent materials</p> <code>None</code> <code>reference</code> <code>References | None</code> <p>Any reference for the material data</p> <code>None</code> <code>mix_condition</code> <code>OpCondT | None</code> <p>The conditions to mix under. These are used to calculate the density of the materials. Defaults to IUPAC STP</p> <code>None</code> <code>**properties_overrides</code> <p>any replacement properties for the mixture eg density</p> required <p>Returns:</p> Type Description <code>Material[ConverterK]</code> <p>Mixed material</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If one material has a property the others dont and there is no override provided</p> Source code in <code>matproplib/material.py</code> <pre><code>def mixture(\n    name: str,\n    materials: Sequence[\n        MaterialFraction[ConverterK] | tuple[Material[ConverterK], float]\n    ],\n    fraction_type: Literal[\"atomic\", \"mass\", \"volume\"] = \"atomic\",\n    converters: Converters[ConverterK] | None = None,\n    reference: References | None = None,\n    *,\n    mix_condition: OpCondT | None = None,\n    **property_overrides: DependentPhysicalProperty,\n) -&gt; Material[ConverterK]:\n    \"\"\"\n    Create a mixture from a set of materials\n\n    Parameters\n    ----------\n    name:\n        Mixture name\n    materials:\n        list of materials with their fractions\n    fraction_type:\n        the type of fractional mixing to perform\n    converters:\n        Conversion to other formats, these are not transferred from constituent materials\n    reference:\n        Any reference for the material data\n    mix_condition:\n        The conditions to mix under.\n        These are used to calculate the density of the materials. Defaults to IUPAC STP\n    **properties_overrides:\n        any replacement properties for the mixture eg density\n\n    Returns\n    -------\n    :\n        Mixed material\n\n    Raises\n    ------\n    AttributeError\n        If one material has a property the others dont and there is no override provided\n    \"\"\"\n    materials: list[MaterialFraction[ConverterK]] = [\n        MaterialFraction.model_validate(m) for m in materials\n    ]\n    if len(materials) == 1:\n        single = materials[0].material\n        return single.model_copy(\n            update=dict(\n                name=name,\n                reference=reference or single.reference,\n                converters=converters or single.converters,\n                mixture_fraction=materials,\n                **property_overrides,\n            )\n        )\n\n    _void_check(materials, fraction_type)\n\n    all_fields = reduce(\n        operator.or_,\n        [type(m.material).model_fields for m in materials],\n        {},\n    )\n    prop_ann, prop_val = {}, {}\n    for prp in all_fields.keys() - Material.model_fields.keys():\n        mix_properties = _get_properties_from_materials(prp, materials)\n        mix_type = _ignore_undefined(all_fields[prp].annotation)\n        prop_ann[prp] = all_fields[prp].annotation | Mixture[mix_type]\n        if prp in property_overrides:\n            prop_val[prp] = property_overrides[prp]\n            continue\n        for dpp in mix_properties[\"dpp\"]:\n            if isinstance(dpp, UndefinedProperty):\n                prop_val[prp] = dpp\n                break\n        else:\n            try:\n                prop_val[prp] = Mixture[mix_type](\n                    **mix_properties, unit=mix_properties[\"dpp\"][0].unit\n                )\n            except ValidationError:\n                mats = \"\".join(\n                    f\"{i}: {materials[i].material.name}\"\n                    for i in _get_indexes(mix_properties[\"dpp\"])\n                )\n                msg = (\n                    f\"Material property '{prp}' not defined and not overidden at {mats} \"\n                )\n                prop_val[prp] = AttributeErrorProperty(msg=msg)\n                log.debug(msg)\n            except AttributeError:\n                if all(\n                    isinstance(sc, UndefinedSuperconductingParameterisation)\n                    for sc in mix_properties[\"dpp\"]\n                ):\n                    prop_val[prp] = mix_properties[\"dpp\"][0]\n                else:\n                    msg = \"Superconducting properties cannot be mixed\"\n                    prop_val[prp] = AttributeErrorSCParameterisation(\n                        critical_current_density=AttributeErrorProperty(msg=msg)\n                    )\n                    log.debug(msg)\n\n    model = create_model(\n        name,\n        __base__=(Material[ConverterK], Generic[ConverterK]),\n        name=(str, name),\n        **prop_ann,\n    )\n\n    return model[ConverterK](\n        **prop_val,\n        elements=_mix_elements(\n            materials, fraction_type, mix_condition or STPConditions()\n        ),\n        reference=reference,\n        converters=converters or Converters(),\n        mixture_fraction=materials,\n    )\n</code></pre>"},{"location":"source/reference/matproplib/material/#matproplib.material.dependentphysicalproperty","title":"<code>dependentphysicalproperty(dpp=DependentPhysicalProperty, *, unit=None, op_cond_config=None, reference=None)</code>","text":"<p>Decorator to create DependentPhysicalProperty for a method</p> <p>Returns:</p> Type Description <code>type[DPPWrap[DPPT]]</code> <p>Wrapped method of a class</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if unit is not specified and dpp is not the base DependentPhysicalPropery</p> Source code in <code>matproplib/material.py</code> <pre><code>def dependentphysicalproperty(\n    dpp: type[DPPT] = DependentPhysicalProperty,\n    *,\n    unit: Unit | str | None = None,\n    op_cond_config: DependentPropertyConditionConfig\n    | DependentPropertyConditionConfigTD\n    | None = None,\n    reference: References | None = None,\n) -&gt; type[DPPWrap[DPPT]]:\n    \"\"\"Decorator to create DependentPhysicalProperty for a method\n\n    Returns\n    -------\n    :\n        Wrapped method of a class\n\n    Raises\n    ------\n    ValueError\n        if unit is not specified and dpp is not the base DependentPhysicalPropery\n    \"\"\"\n    dunit = (\n        dpp.model_fields[\"unit\"].default\n        if (\n            issubclass(dpp, DependentPhysicalProperty)\n            and dpp is not DependentPhysicalProperty\n        )\n        else None\n    )\n\n    if unit is None and dunit is None:\n        raise ValueError(\"Unit must be specified for function output\")\n\n    class Wrap(_Wrapped, Generic[_T]):\n        \"\"\"Wrap a function to make a DependentPhysicalProperty\n\n        Returns\n        -------\n        :\n            Wrapped function\n\n        Notes\n        -----\n        Pydantic special cases functools entries\n        \"\"\"\n\n        def __init__(\n            self,\n            func: Callable[[Material, OpCondT], float] | Callable[[OpCondT], float],\n        ):\n            self.__create_model(func)\n\n        def __create_model(self, func):\n            self.__model = create_model(\n                func.__name__,\n                __base__=dpp,\n                value=(\n                    Callable[[Material, OpCondT], float],\n                    Field(default=func, validate_default=True),\n                ),\n                unit=(\n                    Unit | str,\n                    Field(\n                        default=dunit if dunit is not None else unit,\n                        validate_default=True,\n                    ),\n                ),\n                op_cond_config=(\n                    DependentPropertyConditionConfig | None,\n                    Field(default=op_cond_config, validate_default=True),\n                ),\n                reference=(\n                    References | None,\n                    Field(default=reference, validate_default=True),\n                ),\n            )(unit=unit if unit is not None else dunit)\n\n        def __get__(self, owner: type[Owner], name: str) -&gt; DependentPhysicalProperty:\n            return self.__model\n\n        def __set_name__(self, _, name: str):\n            \"\"\"Set the attribute name from a dataclass\"\"\"\n            self._name = \"_\" + name\n\n    # Bypass some pydantic checks,\n    Wrap.__module__ = \"functools\"\n\n    return Wrap\n</code></pre>"},{"location":"source/reference/matproplib/nucleides/","title":"nucleides","text":"<p>Nucleides representation</p>"},{"location":"source/reference/matproplib/nucleides/#matproplib.nucleides.ParsedElement","title":"<code>ParsedElement = tuple[Literal['element'], str, int]</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/nucleides/#matproplib.nucleides.ParsedCount","title":"<code>ParsedCount = tuple[Literal['count'], int]</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/nucleides/#matproplib.nucleides.ParsedGroup","title":"<code>ParsedGroup = tuple[Literal['group'], list[Union['ParsedGroup', ParsedElement, ParsedCount]]]</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/nucleides/#matproplib.nucleides.ParsedFormula","title":"<code>ParsedFormula = list[ParsedElement | ParsedGroup | ParsedCount]</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/nucleides/#matproplib.nucleides.ElementFraction","title":"<code>ElementFraction</code>","text":"<p>               Bases: <code>PMBaseModel</code></p> <p>Elemental fraction model</p> Source code in <code>matproplib/nucleides.py</code> <pre><code>class ElementFraction(PMBaseModel):\n    \"\"\"Elemental fraction model\"\"\"\n\n    element: Element\n    fraction: NonNegativeFloat\n</code></pre>"},{"location":"source/reference/matproplib/nucleides/#matproplib.nucleides.ElementFraction.element","title":"<code>element</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/nucleides/#matproplib.nucleides.ElementFraction.fraction","title":"<code>fraction</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/nucleides/#matproplib.nucleides.ElementsTD","title":"<code>ElementsTD</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Strict typing of Elements.root</p> Source code in <code>matproplib/nucleides.py</code> <pre><code>class ElementsTD(TypedDict, total=False, extra_items=ElementFraction | float):\n    \"\"\"Strict typing of Elements.root\"\"\"\n\n    _no_atoms: int\n    reference: References | None\n    fraction_type: Literal[\"atomic\", \"mass\"]\n</code></pre>"},{"location":"source/reference/matproplib/nucleides/#matproplib.nucleides.ElementsTD.reference","title":"<code>reference</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/nucleides/#matproplib.nucleides.ElementsTD.fraction_type","title":"<code>fraction_type</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/nucleides/#matproplib.nucleides.Elements","title":"<code>Elements</code>","text":"<p>               Bases: <code>RootModel</code></p> <p>Element grouping model</p> Source code in <code>matproplib/nucleides.py</code> <pre><code>class Elements(RootModel):\n    \"\"\"Element grouping model\"\"\"\n\n    root: ElementsTD\n    _no_atoms: int | None = None\n    _reference: References | None = None\n    model_config = ConfigDict(validate_default=True)\n\n    @model_validator(mode=\"before\")\n    def _element_pre_validation(self):\n        if isinstance(self, str):\n            # conversion is always fraction by atom \"atomic\"\n            return convert_chemical_equation_to_elements(self)\n        if isinstance(self, ElementFraction):\n            return {self.element.element.symbol: self}\n        if isinstance(self, list):\n            if len(self) == 1 and isinstance(self[0], str):\n                return {self[0]: 1}\n            ret = {}\n            for e in self:\n                el = ElementFraction.model_validate(e)\n                ret[el.element.element.symbol] = el\n            return ret\n\n        for k, v in self.items():\n            if isinstance(v, float):\n                self[k] = float(v)\n        return self\n\n    @model_validator(mode=\"after\")\n    def _element_post_validation(self):\n        self._reference = self.root.pop(\"reference\", None)\n        self._no_atoms = self.root.pop(\"no_atoms\", None)\n        fraction_type = self.root.pop(\"fraction_type\", \"atomic\")\n\n        for k, v in self.root.items():\n            if not isinstance(v, ElementFraction):\n                self.root[k] = ElementFraction(element=k, fraction=v)\n\n        self.root = _from_fraction_type_conversion(fraction_type, self.root)\n\n        e_sum = 0\n        for e in self.root.values():\n            e_sum += e.fraction\n\n        if not np.isclose(e_sum, 1, atol=1e-5, rtol=1e-5) and len(self) &gt; 0:\n            log.info(f\"Fraction does not sum to 1, total: {e_sum:.5f}\")\n\n        if e_sum &gt; 1 and not np.isclose(e_sum, 1, atol=1e-5, rtol=1e-5):\n            raise ValueError(f\"The fraction of elements is greater than 1: {e_sum:.5f}\")\n        return self\n\n    @model_serializer\n    def _elements_serialise(self) -&gt; dict[str, float]:\n        ref = {} if self._reference is None else {\"reference\": self._reference}\n        return {k: e.fraction for k, e in self.root.items()} | ref\n\n    def __iter__(self):  # noqa: D105\n        return iter(self.root.items())\n\n    def __getitem__(self, item):  # noqa: D105\n        return self.root[item]\n\n    def __len__(self) -&gt; int:  # noqa: D105\n        return len(self.root)\n\n    def __repr__(self):  # noqa: D105\n        return f\"{type(self).__name__}({self._elements_serialise()})\"\n\n    def __getattr__(self, name: str):\n        \"\"\"Gets reference if requested\"\"\"  # noqa: DOC201\n        if name == \"reference\":\n            return self._reference\n        return super().__getattr__(name)\n\n    @property\n    def nucleides(self) -&gt; Elements:\n        \"\"\"Get the nucleides for a given element group\n\n        Returns\n        -------\n        :\n            Expanded model only consisting of nucleides\n\n        Notes\n        -----\n        Natural abundance is used for elements\n        \"\"\"\n        return Elements(**{\n            f\"{iso.element.element.symbol}{iso.element.isotope}\": {\n                \"element\": iso,\n                \"fraction\": _modify_fraction(ef, iso),\n            }\n            for ef in self.root.values()\n            for iso in ef.element.nucleides\n        })\n\n    @property\n    def average_molar_mass(self) -&gt; float:\n        \"\"\"Average molar mass of elements\"\"\"\n        mass, moles = 0, 0\n\n        for ef in self.root.values():\n            mass += ef.fraction * ef.element.element.mass\n            moles += ef.fraction\n\n        return mass / moles\n</code></pre>"},{"location":"source/reference/matproplib/nucleides/#matproplib.nucleides.Elements.root","title":"<code>root</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/nucleides/#matproplib.nucleides.Elements.model_config","title":"<code>model_config = ConfigDict(validate_default=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/nucleides/#matproplib.nucleides.Elements.nucleides","title":"<code>nucleides</code>  <code>property</code>","text":"<p>Get the nucleides for a given element group</p> <p>Returns:</p> Type Description <code>Elements</code> <p>Expanded model only consisting of nucleides</p> Notes <p>Natural abundance is used for elements</p>"},{"location":"source/reference/matproplib/nucleides/#matproplib.nucleides.Elements.average_molar_mass","title":"<code>average_molar_mass</code>  <code>property</code>","text":"<p>Average molar mass of elements</p>"},{"location":"source/reference/matproplib/nucleides/#matproplib.nucleides.Element","title":"<code>Element</code>","text":"<p>               Bases: <code>PMBaseModel</code></p> <p>Element Model</p> Notes <p>Verifies against the Generalised Nuclear Database Structure for metastable nucleides if provided (eg Am242_m1)</p> <p>.. doi:: 10.1787/5f05e3db-en</p> Source code in <code>matproplib/nucleides.py</code> <pre><code>class Element(PMBaseModel):\n    \"\"\"Element Model\n\n    Notes\n    -----\n    Verifies against the Generalised Nuclear Database Structure for metastable nucleides\n    if provided (eg Am242_m1)\n\n    .. doi:: 10.1787/5f05e3db-en\n\n    \"\"\"\n\n    element: pt.core.Element | pt.core.Isotope\n    metastable: int = 0\n\n    @model_validator(mode=\"before\")\n    def _split_into_parts(self):\n        if isinstance(self, str):\n            self = {\"element\": self}  # noqa: PLW0642\n\n        if isinstance(self, dict) and not isinstance(\n            self.get(\"element\"), pt.core.Isotope | pt.core.Element\n        ):\n            symbol, a_n, state = _GNDS_metaStable.fullmatch(self[\"element\"]).groups()\n\n            symbol = getattr(pt, symbol)\n\n            self[\"element\"] = symbol if a_n is None else symbol[int(a_n)]\n            self[\"metastable\"] = int(state[2:]) if state else self.get(\"metastable\", 0)\n        return self\n\n    @property\n    def mass_number(self) -&gt; int:\n        \"\"\"Atomic mass number\n\n        Notes\n        -----\n        Returns highest abundance mass number for elements\n        \"\"\"\n        if isinstance(self.element, pt.core.Isotope):\n            return self.element.isotope\n        return most_abundant_isoptope(self.element).isotope\n\n    @property\n    def atomic_number(self) -&gt; int:\n        \"\"\"Atomic number\"\"\"\n        return self.element.number\n\n    @property\n    def zaid(self) -&gt; str:\n        \"\"\"ZAID structure for the element\"\"\"\n        return f\"{self.atomic_number:03}{self.mass_number:03}\"\n\n    @property\n    def nucleides(self):\n        \"\"\"Nucleides of the element\n\n        Yields\n        ------\n        :\n            The nucleide if its an isotope or the natural abundance nucleides\n        \"\"\"\n        if isinstance(self.element, pt.core.Isotope):\n            yield self\n        else:\n            for iso in list(self.element):\n                if iso.abundance &gt; 0:\n                    yield Element(element=iso, metastable=self.metastable)\n</code></pre>"},{"location":"source/reference/matproplib/nucleides/#matproplib.nucleides.Element.element","title":"<code>element</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/nucleides/#matproplib.nucleides.Element.metastable","title":"<code>metastable = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/nucleides/#matproplib.nucleides.Element.mass_number","title":"<code>mass_number</code>  <code>property</code>","text":"<p>Atomic mass number</p> Notes <p>Returns highest abundance mass number for elements</p>"},{"location":"source/reference/matproplib/nucleides/#matproplib.nucleides.Element.atomic_number","title":"<code>atomic_number</code>  <code>property</code>","text":"<p>Atomic number</p>"},{"location":"source/reference/matproplib/nucleides/#matproplib.nucleides.Element.zaid","title":"<code>zaid</code>  <code>property</code>","text":"<p>ZAID structure for the element</p>"},{"location":"source/reference/matproplib/nucleides/#matproplib.nucleides.Element.nucleides","title":"<code>nucleides</code>  <code>property</code>","text":"<p>Nucleides of the element</p> <p>Yields:</p> Type Description <p>The nucleide if its an isotope or the natural abundance nucleides</p>"},{"location":"source/reference/matproplib/nucleides/#matproplib.nucleides.most_abundant_isoptope","title":"<code>most_abundant_isoptope(el)</code>","text":"<p>Returns:</p> Type Description <code>Isotope</code> <p>The most naturally abundant nucleide</p> Source code in <code>matproplib/nucleides.py</code> <pre><code>def most_abundant_isoptope(el: pt.core.Element) -&gt; pt.core.Isotope:\n    \"\"\"\n    Returns\n    -------\n    :\n        The most naturally abundant nucleide\n    \"\"\"\n    return max(list(el), key=lambda x: x.abundance)\n</code></pre>"},{"location":"source/reference/matproplib/nucleides/#matproplib.nucleides.mass_fraction_to_atomic_fraction","title":"<code>mass_fraction_to_atomic_fraction(ef_dict)</code>","text":"<p>Returns:</p> Type Description <code>ElementsTD</code> <p>Atomic fraction of model</p> Source code in <code>matproplib/nucleides.py</code> <pre><code>def mass_fraction_to_atomic_fraction(ef_dict: ElementsTD) -&gt; ElementsTD:\n    \"\"\"\n    Returns\n    -------\n    :\n        Atomic fraction of model\n    \"\"\"\n    return _converter(ef_dict, lambda ef: ef.fraction / ef.element.element.mass)\n</code></pre>"},{"location":"source/reference/matproplib/nucleides/#matproplib.nucleides.atomic_fraction_to_mass_fraction","title":"<code>atomic_fraction_to_mass_fraction(ef_dict)</code>","text":"<p>Returns:</p> Type Description <code>ElementsTD</code> <p>Mass fraction of model</p> Source code in <code>matproplib/nucleides.py</code> <pre><code>def atomic_fraction_to_mass_fraction(ef_dict: ElementsTD) -&gt; ElementsTD:\n    \"\"\"\n    Returns\n    -------\n    :\n        Mass fraction of model\n    \"\"\"\n    return _converter(ef_dict, lambda ef: ef.fraction * ef.element.element.mass)\n</code></pre>"},{"location":"source/reference/matproplib/nucleides/#matproplib.nucleides.mass_fraction_to_volume_fraction","title":"<code>mass_fraction_to_volume_fraction(ef_dict, densities)</code>","text":"<p>Returns:</p> Type Description <code>ElementsTD</code> <p>Volume fraction of model</p> Source code in <code>matproplib/nucleides.py</code> <pre><code>def mass_fraction_to_volume_fraction(\n    ef_dict: ElementsTD, densities: dict[str, float]\n) -&gt; ElementsTD:\n    \"\"\"\n    Returns\n    -------\n    :\n        Volume fraction of model\n    \"\"\"\n    return _converter(ef_dict, lambda ef: ef.fraction / _get_dn(densities, ef.element))\n</code></pre>"},{"location":"source/reference/matproplib/nucleides/#matproplib.nucleides.volume_fraction_to_mass_fraction","title":"<code>volume_fraction_to_mass_fraction(ef_dict, densities)</code>","text":"<p>Returns:</p> Type Description <code>ElementsTD</code> <p>Mass fraction of model</p> Source code in <code>matproplib/nucleides.py</code> <pre><code>def volume_fraction_to_mass_fraction(\n    ef_dict: ElementsTD, densities: dict[str, float]\n) -&gt; ElementsTD:\n    \"\"\"\n    Returns\n    -------\n    :\n        Mass fraction of model\n    \"\"\"\n    return _converter(ef_dict, lambda ef: ef.fraction * _get_dn(densities, ef.element))\n</code></pre>"},{"location":"source/reference/matproplib/nucleides/#matproplib.nucleides.atomic_fraction_to_volume_fraction","title":"<code>atomic_fraction_to_volume_fraction(ef_dict, densities)</code>","text":"<p>Returns:</p> Type Description <code>ElementsTD</code> <p>Volume fraction of model</p> Source code in <code>matproplib/nucleides.py</code> <pre><code>def atomic_fraction_to_volume_fraction(\n    ef_dict: ElementsTD, densities: dict[str, float]\n) -&gt; ElementsTD:\n    \"\"\"\n    Returns\n    -------\n    :\n        Volume fraction of model\n    \"\"\"\n    return _converter(\n        ef_dict,\n        lambda ef: ef.fraction\n        * ef.element.element.mass\n        / _get_dn(densities, ef.element),\n    )\n</code></pre>"},{"location":"source/reference/matproplib/nucleides/#matproplib.nucleides.volume_fraction_to_atomic_fraction","title":"<code>volume_fraction_to_atomic_fraction(ef_dict, densities)</code>","text":"<p>Returns:</p> Type Description <code>ElementsTD</code> <p>Atomic fraction of model</p> Source code in <code>matproplib/nucleides.py</code> <pre><code>def volume_fraction_to_atomic_fraction(\n    ef_dict: ElementsTD, densities: dict[str, float]\n) -&gt; ElementsTD:\n    \"\"\"\n    Returns\n    -------\n    :\n        Atomic fraction of model\n    \"\"\"\n    return _converter(\n        ef_dict,\n        lambda ef: ef.fraction\n        * _get_dn(densities, ef.element)\n        / ef.element.element.mass,\n    )\n</code></pre>"},{"location":"source/reference/matproplib/nucleides/#matproplib.nucleides.parse_chemical_formula","title":"<code>parse_chemical_formula(formula)</code>","text":"<p>Parse a chemical formula into its constituent elements</p> <p>Returns:</p> Type Description <code>ParsedFormula</code> <p>Parsed formula</p> Source code in <code>matproplib/nucleides.py</code> <pre><code>def parse_chemical_formula(formula: str) -&gt; ParsedFormula:\n    \"\"\"Parse a chemical formula into its constituent elements\n\n    Returns\n    -------\n    :\n        Parsed formula\n    \"\"\"\n    el_str = r\"[A-Z][a-z]*\"\n    element_pattern = re.compile(el_str)\n\n    def digits(tokens: list[str]) -&gt; int:\n        return int(tokens.pop(0)) if tokens and tokens[0].isdigit() else 1\n\n    def parse(tokens: list[str]) -&gt; ParsedFormula:\n        parsed: ParsedFormula = []\n        while tokens:\n            token = tokens.pop(0)\n            if token == \"(\":  # noqa: S105\n                sub_parsed = parse(tokens)\n                multiplier = digits(tokens)\n                parsed.append((\"group\", [*sub_parsed, (\"count\", multiplier)]))\n            elif token == \")\":  # noqa: S105\n                break\n            elif element_pattern.match(token):\n                element = token\n                count = digits(tokens)\n                parsed.append((\"element\", element, count))\n        return parsed\n\n    parsed = parse(re.findall(rf\"{el_str}|\\d+|\\(|\\)\", formula))\n    _unparse_check(formula, parsed)\n    return parsed\n</code></pre>"},{"location":"source/reference/matproplib/nucleides/#matproplib.nucleides.convert_chemical_equation_to_elements","title":"<code>convert_chemical_equation_to_elements(formula)</code>","text":"<p>Convert chemical formula into a form ingestable by Elements</p> <p>Returns:</p> Type Description <code>dict[str, ElementFraction]</code> <p>dictionary of ElementFractions</p> Source code in <code>matproplib/nucleides.py</code> <pre><code>def convert_chemical_equation_to_elements(formula: str) -&gt; dict[str, ElementFraction]:\n    \"\"\"Convert chemical formula into a form ingestable by Elements\n\n    Returns\n    -------\n    :\n        dictionary of ElementFractions\n    \"\"\"\n\n    def add_fraction(\n        el1: dict[str, ElementFraction], el2: dict[str, ElementFraction]\n    ) -&gt; dict[str, ElementFraction]:\n        for k, v in el1.items():\n            if k in el2:\n                el2[k].fraction += v.fraction\n            else:\n                el2[k] = v\n        return el2\n\n    def parse(\n        tokens: ParsedFormula, elements: dict[str, ElementFraction]\n    ) -&gt; dict[str, ElementFraction]:\n        new_elements: dict[str, ElementFraction] = {}\n        for tok in tokens:\n            if tok[0] == \"element\":\n                if tok[1] in new_elements:\n                    new_elements[tok[1]].fraction += tok[2]\n                else:\n                    new_elements[tok[1]] = ElementFraction(\n                        element=tok[1], fraction=tok[2]\n                    )\n            elif tok[0] == \"group\":\n                group_elements = parse(tok[1], {})\n                new_elements = add_fraction(group_elements, new_elements)\n            elif tok[0] == \"count\":\n                for v in new_elements.values():\n                    v.fraction *= tok[1]\n\n        return add_fraction(new_elements, elements)\n\n    elements = parse(parse_chemical_formula(formula), {})\n    ttl_fraction = sum(e.fraction for e in elements.values())\n    no_atoms = 0\n    for v in elements.values():\n        no_atoms += v.fraction\n        v.fraction /= ttl_fraction\n    return {\"no_atoms\": int(no_atoms), **elements}\n</code></pre>"},{"location":"source/reference/matproplib/superconduction/","title":"superconduction","text":"<p>Dependent properties of matproplib</p>"},{"location":"source/reference/matproplib/superconduction/#matproplib.superconduction.Nb3SnBotturaParameterisation","title":"<code>Nb3SnBotturaParameterisation</code>","text":"<p>               Bases: <code>SuperconductingParameterisation</code></p> <p>ITER-like Bottura-Bordini parameterisation of the critical surface of a Nb3Sn Superconducting strand.</p> <p>.. doi:: 10.1109/TASC.2009.2018278     :title: L. Bottura and B. Bordini, \"JC(B,T,\u03b5) Parameterization for the ITER Nb3Sn Production,\"     in IEEE Transactions on Applied Superconductivity, vol. 19, no. 3, pp. 1521-1524, June 2009</p> Source code in <code>matproplib/superconduction.py</code> <pre><code>@rebuild\nclass Nb3SnBotturaParameterisation(SuperconductingParameterisation):\n    \"\"\"\n    ITER-like Bottura-Bordini parameterisation of the critical surface of\n    a Nb3Sn Superconducting strand.\n\n    .. doi:: 10.1109/TASC.2009.2018278\n        :title: L. Bottura and B. Bordini, \"JC(B,T,\u03b5) Parameterization for the ITER Nb3Sn Production,\"\n        in IEEE Transactions on Applied Superconductivity, vol. 19, no. 3, pp. 1521-1524, June 2009\n    \"\"\"  # noqa: E501\n\n    name: ClassVar[Literal[\"Nb3SnBottura\"]] = \"Nb3SnBottura\"\n    constant: float  # Current density scaling constant\n    p: float  # Low field exponent of the pinning force\n    q: float  # High field exponent of the pinning force\n    c_a1: float  # Strain fitting constant\n    c_a2: float  # Strain fitting constant\n    eps_0a: Strain  # Residual strain component\n    eps_m: Strain  # Tensile strain at which the maximum critical properties are reached\n    b_c20m: MagneticField  # Upper critical field at zero temperature and strain\n    t_c0max: Temperature  # Critical temperature at zero field and strain\n\n    @dependentphysicalproperty(unit=\"A/m^2\")\n    def critical_current_density(self, op_cond: OpCondT) -&gt; float:\n        \"\"\"\n        Calculate the critical current density as a function of temperature,\n        magnetic field, and strain.\n        \"\"\"  # noqa: DOC201\n        temperature = op_cond.temperature\n        field = np.maximum(0.001, op_cond.magnetic_field)  # Avoid division by zero\n        strain = op_cond.strain\n\n        s = _nb3sn_strain_twente(strain, self.c_a1, self.c_a2, self.eps_0a)\n\n        t_zero = self.t_c0max * s ** (1.0 / 3.0)\n        reduced_t = temperature / t_zero\n        t_152 = np.where(reduced_t &gt; 0, reduced_t**1.52, reduced_t)\n\n        b_crit = self.b_c20m * s * (1.0 - t_152)\n        reduced_b = field / b_crit\n\n        result = self.constant / field * s * (1.0 - t_152) * (1.0 - reduced_t**2)\n\n        j_crit = np.zeros_like(reduced_b)\n        ind = np.where((reduced_b &lt; 1.0) &amp; (reduced_b &gt; 0), True, False)  # noqa: FBT003\n        inv_ind = ~ind\n        reduced_b_ind = reduced_b[ind]\n        reduced_b_not_ind = reduced_b[inv_ind]\n\n        # Apply kludging to avoid negative values and NaNs.\n        j_crit[ind] = (\n            result[ind] * reduced_b_ind**self.p * (1.0 - reduced_b_ind) ** self.q\n        )\n        j_crit[inv_ind] = result[inv_ind] * reduced_b_not_ind * (1.0 - reduced_b_not_ind)\n\n        return kludge_linear_spline(j_crit, 10.0, 1.0)\n</code></pre>"},{"location":"source/reference/matproplib/superconduction/#matproplib.superconduction.Nb3SnBotturaParameterisation.name","title":"<code>name = 'Nb3SnBottura'</code>  <code>class-attribute</code>","text":""},{"location":"source/reference/matproplib/superconduction/#matproplib.superconduction.Nb3SnBotturaParameterisation.constant","title":"<code>constant</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/superconduction/#matproplib.superconduction.Nb3SnBotturaParameterisation.p","title":"<code>p</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/superconduction/#matproplib.superconduction.Nb3SnBotturaParameterisation.q","title":"<code>q</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/superconduction/#matproplib.superconduction.Nb3SnBotturaParameterisation.c_a1","title":"<code>c_a1</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/superconduction/#matproplib.superconduction.Nb3SnBotturaParameterisation.c_a2","title":"<code>c_a2</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/superconduction/#matproplib.superconduction.Nb3SnBotturaParameterisation.eps_0a","title":"<code>eps_0a</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/superconduction/#matproplib.superconduction.Nb3SnBotturaParameterisation.eps_m","title":"<code>eps_m</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/superconduction/#matproplib.superconduction.Nb3SnBotturaParameterisation.b_c20m","title":"<code>b_c20m</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/superconduction/#matproplib.superconduction.Nb3SnBotturaParameterisation.t_c0max","title":"<code>t_c0max</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/superconduction/#matproplib.superconduction.Nb3SnBotturaParameterisation.critical_current_density","title":"<code>critical_current_density(op_cond)</code>","text":"<p>Calculate the critical current density as a function of temperature, magnetic field, and strain.</p> Source code in <code>matproplib/superconduction.py</code> <pre><code>@dependentphysicalproperty(unit=\"A/m^2\")\ndef critical_current_density(self, op_cond: OpCondT) -&gt; float:\n    \"\"\"\n    Calculate the critical current density as a function of temperature,\n    magnetic field, and strain.\n    \"\"\"  # noqa: DOC201\n    temperature = op_cond.temperature\n    field = np.maximum(0.001, op_cond.magnetic_field)  # Avoid division by zero\n    strain = op_cond.strain\n\n    s = _nb3sn_strain_twente(strain, self.c_a1, self.c_a2, self.eps_0a)\n\n    t_zero = self.t_c0max * s ** (1.0 / 3.0)\n    reduced_t = temperature / t_zero\n    t_152 = np.where(reduced_t &gt; 0, reduced_t**1.52, reduced_t)\n\n    b_crit = self.b_c20m * s * (1.0 - t_152)\n    reduced_b = field / b_crit\n\n    result = self.constant / field * s * (1.0 - t_152) * (1.0 - reduced_t**2)\n\n    j_crit = np.zeros_like(reduced_b)\n    ind = np.where((reduced_b &lt; 1.0) &amp; (reduced_b &gt; 0), True, False)  # noqa: FBT003\n    inv_ind = ~ind\n    reduced_b_ind = reduced_b[ind]\n    reduced_b_not_ind = reduced_b[inv_ind]\n\n    # Apply kludging to avoid negative values and NaNs.\n    j_crit[ind] = (\n        result[ind] * reduced_b_ind**self.p * (1.0 - reduced_b_ind) ** self.q\n    )\n    j_crit[inv_ind] = result[inv_ind] * reduced_b_not_ind * (1.0 - reduced_b_not_ind)\n\n    return kludge_linear_spline(j_crit, 10.0, 1.0)\n</code></pre>"},{"location":"source/reference/matproplib/superconduction/#matproplib.superconduction.NbTiBotturaParameterisation","title":"<code>NbTiBotturaParameterisation</code>","text":"<p>               Bases: <code>SuperconductingParameterisation</code></p> <p>ITER-like Bottura parameterisation of the critical surface of a NbTi Superconducting strand. (strain-independent)</p> <p>..doi:: 10.1109/77.828413     :title: L. Bottura, \"A practical fit for the critical surface of NbTi,\"     in IEEE Transactions on Applied Superconductivity, vol. 10, no. 1, pp. 1054-1057, March 2000,</p> Source code in <code>matproplib/superconduction.py</code> <pre><code>@rebuild\nclass NbTiBotturaParameterisation(SuperconductingParameterisation):\n    \"\"\"\n    ITER-like Bottura parameterisation of the critical surface of\n    a NbTi Superconducting strand. (strain-independent)\n\n    ..doi:: 10.1109/77.828413\n        :title: L. Bottura, \"A practical fit for the critical surface of NbTi,\"\n        in IEEE Transactions on Applied Superconductivity, vol. 10, no. 1, pp. 1054-1057, March 2000,\n    \"\"\"  # noqa: E501\n\n    name: ClassVar[Literal[\"NbTiBottura\"]] = \"NbTiBottura\"\n\n    constant: float  # Current density scaling constant\n    alpha: float  # Low field exponent of the pinning force\n    beta: float  # High field exponent of the pinning force\n    gamma: float  # High temperature exponent (?)\n    t_c0: Temperature  # Critical temperature at zero field\n    b_c20: MagneticField  # Upper critical flux density at zero temperature\n\n    @dependentphysicalproperty(unit=\"A/m^2\")\n    def critical_current_density(self, op_cond: OpCondT) -&gt; float:\n        \"\"\"\n        Calculate the critical current density as a function of temperature\n        and magnetic field.\n        \"\"\"  # noqa: DOC201\n        field = np.maximum(0.001, op_cond.magnetic_field)  # Avoid division by zero\n        temperature = op_cond.temperature\n\n        reduced_t = temperature / self.t_c0\n        temp_term = np.where(reduced_t &gt; 0, 1 - reduced_t**1.7, 1 - reduced_t)\n\n        b_c2 = self.b_c20 * temp_term\n        reduced_b = field / b_c2\n\n        result = self.constant / field * temp_term**self.gamma\n        # Apply kludging to avoid negative values and NaNs.\n        j_crit = np.where(\n            (reduced_b &lt; 1.0) &amp; (reduced_b &gt; 0),\n            result * (reduced_b**self.alpha) * (1 - reduced_b) ** self.beta,\n            result * reduced_b * (1 - reduced_b),\n        )\n\n        return kludge_linear_spline(j_crit, 20.0, 10.0)\n</code></pre>"},{"location":"source/reference/matproplib/superconduction/#matproplib.superconduction.NbTiBotturaParameterisation.name","title":"<code>name = 'NbTiBottura'</code>  <code>class-attribute</code>","text":""},{"location":"source/reference/matproplib/superconduction/#matproplib.superconduction.NbTiBotturaParameterisation.constant","title":"<code>constant</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/superconduction/#matproplib.superconduction.NbTiBotturaParameterisation.alpha","title":"<code>alpha</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/superconduction/#matproplib.superconduction.NbTiBotturaParameterisation.beta","title":"<code>beta</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/superconduction/#matproplib.superconduction.NbTiBotturaParameterisation.gamma","title":"<code>gamma</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/superconduction/#matproplib.superconduction.NbTiBotturaParameterisation.t_c0","title":"<code>t_c0</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/superconduction/#matproplib.superconduction.NbTiBotturaParameterisation.b_c20","title":"<code>b_c20</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/superconduction/#matproplib.superconduction.NbTiBotturaParameterisation.critical_current_density","title":"<code>critical_current_density(op_cond)</code>","text":"<p>Calculate the critical current density as a function of temperature and magnetic field.</p> Source code in <code>matproplib/superconduction.py</code> <pre><code>@dependentphysicalproperty(unit=\"A/m^2\")\ndef critical_current_density(self, op_cond: OpCondT) -&gt; float:\n    \"\"\"\n    Calculate the critical current density as a function of temperature\n    and magnetic field.\n    \"\"\"  # noqa: DOC201\n    field = np.maximum(0.001, op_cond.magnetic_field)  # Avoid division by zero\n    temperature = op_cond.temperature\n\n    reduced_t = temperature / self.t_c0\n    temp_term = np.where(reduced_t &gt; 0, 1 - reduced_t**1.7, 1 - reduced_t)\n\n    b_c2 = self.b_c20 * temp_term\n    reduced_b = field / b_c2\n\n    result = self.constant / field * temp_term**self.gamma\n    # Apply kludging to avoid negative values and NaNs.\n    j_crit = np.where(\n        (reduced_b &lt; 1.0) &amp; (reduced_b &gt; 0),\n        result * (reduced_b**self.alpha) * (1 - reduced_b) ** self.beta,\n        result * reduced_b * (1 - reduced_b),\n    )\n\n    return kludge_linear_spline(j_crit, 20.0, 10.0)\n</code></pre>"},{"location":"source/reference/matproplib/superconduction/#matproplib.superconduction.SummersParameterisation","title":"<code>SummersParameterisation</code>","text":"<p>               Bases: <code>SuperconductingParameterisation</code></p> <p>Summers' parameterisation of the critical surface of an A-15 type superconducting strand.</p> <p>https://scispace.com/pdf/a-model-for-the-prediction-of-nb-sub-3-sn-critical-current-xoujezlpxh.pdf see e.g. https://conferences.lbl.gov/event/979/contributions/5985/attachments/4069/3482/U9-U10_final.pdf, slide 25</p> Source code in <code>matproplib/superconduction.py</code> <pre><code>@rebuild\nclass SummersParameterisation(SuperconductingParameterisation):\n    \"\"\"\n    Summers' parameterisation of the critical surface of\n    an A-15 type superconducting strand.\n\n    https://scispace.com/pdf/a-model-for-the-prediction-of-nb-sub-3-sn-critical-current-xoujezlpxh.pdf\n    see e.g. https://conferences.lbl.gov/event/979/contributions/5985/attachments/4069/3482/U9-U10_final.pdf, slide 25\n\n    \"\"\"  # noqa: E501\n\n    name: ClassVar[Literal[\"Summers\"]] = \"Summers\"\n\n    constant: float  # Current density scaling constant\n    alpha: float  # Strain function exponent (Ekin-like)\n    t_c0m: Temperature  # Critical temperature at zero field and max strain\n    b_c20m: (\n        MagneticField  # Upper critical flux density at zero temperature and max strain\n    )\n\n    @dependentphysicalproperty(unit=\"A/m^2\")\n    def critical_current_density(self, op_cond: OpCondT) -&gt; float:\n        \"\"\"\n        Calculate the critical current density as a function of temperature,\n        magnetic field, and strain.\n        \"\"\"  # noqa: DOC201\n        field = np.maximum(0.001, op_cond.magnetic_field)  # Avoid division by zero\n        temperature = op_cond.temperature\n        f_strain = 1.0 - self.alpha * abs(op_cond.strain) ** 1.7\n\n        constant = self.constant * np.sqrt(f_strain) / np.sqrt(field)\n\n        b_c20 = self.b_c20m * f_strain\n        t_c0 = self.t_c0m * f_strain ** (1.0 / 3.0)\n        r_temp = temperature / t_c0\n        r_temp_sq = r_temp**2\n        b_c2 = (\n            b_c20\n            * (1 - r_temp_sq)\n            * (1 - 0.31 * r_temp_sq * (1 - 1.77 * np.log(r_temp)))\n        )\n        reduced_b = field / b_c2\n        result = np.where(\n            (reduced_b &lt; 1.0) &amp; (reduced_b &gt; 0),\n            constant * (1 - reduced_b) ** 2 * (1 - r_temp_sq) ** 2,\n            constant * (1 - reduced_b) * (1 - r_temp_sq) ** 2,\n        )\n        return kludge_linear_spline(result, 10.0, 1.0)\n</code></pre>"},{"location":"source/reference/matproplib/superconduction/#matproplib.superconduction.SummersParameterisation.name","title":"<code>name = 'Summers'</code>  <code>class-attribute</code>","text":""},{"location":"source/reference/matproplib/superconduction/#matproplib.superconduction.SummersParameterisation.constant","title":"<code>constant</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/superconduction/#matproplib.superconduction.SummersParameterisation.alpha","title":"<code>alpha</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/superconduction/#matproplib.superconduction.SummersParameterisation.t_c0m","title":"<code>t_c0m</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/superconduction/#matproplib.superconduction.SummersParameterisation.b_c20m","title":"<code>b_c20m</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/superconduction/#matproplib.superconduction.SummersParameterisation.critical_current_density","title":"<code>critical_current_density(op_cond)</code>","text":"<p>Calculate the critical current density as a function of temperature, magnetic field, and strain.</p> Source code in <code>matproplib/superconduction.py</code> <pre><code>@dependentphysicalproperty(unit=\"A/m^2\")\ndef critical_current_density(self, op_cond: OpCondT) -&gt; float:\n    \"\"\"\n    Calculate the critical current density as a function of temperature,\n    magnetic field, and strain.\n    \"\"\"  # noqa: DOC201\n    field = np.maximum(0.001, op_cond.magnetic_field)  # Avoid division by zero\n    temperature = op_cond.temperature\n    f_strain = 1.0 - self.alpha * abs(op_cond.strain) ** 1.7\n\n    constant = self.constant * np.sqrt(f_strain) / np.sqrt(field)\n\n    b_c20 = self.b_c20m * f_strain\n    t_c0 = self.t_c0m * f_strain ** (1.0 / 3.0)\n    r_temp = temperature / t_c0\n    r_temp_sq = r_temp**2\n    b_c2 = (\n        b_c20\n        * (1 - r_temp_sq)\n        * (1 - 0.31 * r_temp_sq * (1 - 1.77 * np.log(r_temp)))\n    )\n    reduced_b = field / b_c2\n    result = np.where(\n        (reduced_b &lt; 1.0) &amp; (reduced_b &gt; 0),\n        constant * (1 - reduced_b) ** 2 * (1 - r_temp_sq) ** 2,\n        constant * (1 - reduced_b) * (1 - r_temp_sq) ** 2,\n    )\n    return kludge_linear_spline(result, 10.0, 1.0)\n</code></pre>"},{"location":"source/reference/matproplib/converters/base/","title":"base","text":"<p>Dependent properties of matproplib</p>"},{"location":"source/reference/matproplib/converters/base/#matproplib.converters.base.ConverterK","title":"<code>ConverterK = TypeVar('ConverterK', bound=str)</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/converters/base/#matproplib.converters.base.Converters","title":"<code>Converters</code>","text":"<p>               Bases: <code>RootModel[ConverterK]</code>, <code>Generic[ConverterK]</code></p> <p>Converter grouping object</p> <p>Collects all objects to convert materials into other formats</p> Source code in <code>matproplib/converters/base.py</code> <pre><code>class Converters(RootModel[ConverterK], Generic[ConverterK]):\n    \"\"\"\n    Converter grouping object\n\n    Collects all objects to convert materials into other formats\n    \"\"\"\n\n    root: SerializeAsAny[dict[ConverterK, Converter]] = Field(default_factory=dict)\n\n    def add(self, converter: Converter):\n        \"\"\"Add a converter to the group\"\"\"\n        self.root[converter.name] = converter\n\n    @model_validator(mode=\"before\")\n    def _validation(self):\n        if not isinstance(self, dict | Converter) and isinstance(self, Iterable):\n            return {conv.name: conv for conv in self}\n        if isinstance(self, Converter):\n            return {self.name: self}\n        if isinstance(self, dict):\n            return {\n                k: conv_cls.model_validate(self)\n                for k in self\n                for conv_cls in all_subclasses(Converter)\n                if hasattr(conv_cls, \"name\") and conv_cls.name == k\n            }\n        return self\n\n    def __iter__(self):  # noqa: D105\n        return iter(self.root.items())\n\n    def __getitem__(self, item):  # noqa: D105\n        return self.root[item]\n\n    def __getattr__(self, name: str):  # noqa: D105\n        if name == \"root\":\n            return super().__getattr__(name)\n        return self.__getitem__(name)\n\n    def __setattr__(self, name: str, value):  # noqa: D105\n        if name == \"root\":\n            super().__setattr__(name, value)\n        self.root[name] = value\n\n    def __repr__(self) -&gt; str:  # noqa: D105\n        converters = \", \".join(v.__repr__() for v in self.root.values())\n        return f\"{type(self).__name__}({converters})\"\n</code></pre>"},{"location":"source/reference/matproplib/converters/base/#matproplib.converters.base.Converters.root","title":"<code>root = Field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/converters/base/#matproplib.converters.base.Converters.add","title":"<code>add(converter)</code>","text":"<p>Add a converter to the group</p> Source code in <code>matproplib/converters/base.py</code> <pre><code>def add(self, converter: Converter):\n    \"\"\"Add a converter to the group\"\"\"\n    self.root[converter.name] = converter\n</code></pre>"},{"location":"source/reference/matproplib/converters/base/#matproplib.converters.base.Converter","title":"<code>Converter</code>","text":"<p>               Bases: <code>PMBaseModel</code>, <code>ABC</code></p> <p>Base converter object for material format converters</p> Source code in <code>matproplib/converters/base.py</code> <pre><code>class Converter(PMBaseModel, ABC):\n    \"\"\"Base converter object for material format converters\"\"\"\n\n    name: str\n\n    @abstractmethod\n    def convert(self, material: Material, op_cond: OpCondT):\n        \"\"\"Function to convert material to secondary format\"\"\"\n</code></pre>"},{"location":"source/reference/matproplib/converters/base/#matproplib.converters.base.Converter.name","title":"<code>name</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/converters/base/#matproplib.converters.base.Converter.convert","title":"<code>convert(material, op_cond)</code>  <code>abstractmethod</code>","text":"<p>Function to convert material to secondary format</p> Source code in <code>matproplib/converters/base.py</code> <pre><code>@abstractmethod\ndef convert(self, material: Material, op_cond: OpCondT):\n    \"\"\"Function to convert material to secondary format\"\"\"\n</code></pre>"},{"location":"source/reference/matproplib/converters/neutronics/","title":"neutronics","text":"<p>Dependent properties of matproplib</p>"},{"location":"source/reference/matproplib/converters/neutronics/#matproplib.converters.neutronics.global_id","title":"<code>global_id = Counter({'mcnp': 1})</code>  <code>module-attribute</code>","text":"<p>MCNP requires material ID this counter increments if none provided</p>"},{"location":"source/reference/matproplib/converters/neutronics/#matproplib.converters.neutronics.NeutronicConfig","title":"<code>NeutronicConfig</code>","text":"<p>               Bases: <code>Converter</code>, <code>ABC</code></p> <p>Base neutronic property model</p> Source code in <code>matproplib/converters/neutronics.py</code> <pre><code>class NeutronicConfig(Converter, ABC):\n    \"\"\"Base neutronic property model\"\"\"\n</code></pre>"},{"location":"source/reference/matproplib/converters/neutronics/#matproplib.converters.neutronics.OpenMCNeutronicConfig","title":"<code>OpenMCNeutronicConfig</code>","text":"<p>               Bases: <code>NeutronicConfig</code></p> <p>OpenMC neutronic properties model</p> Source code in <code>matproplib/converters/neutronics.py</code> <pre><code>class OpenMCNeutronicConfig(NeutronicConfig):\n    \"\"\"OpenMC neutronic properties model\"\"\"\n\n    name: ClassVar[Literal[\"openmc\"]] = \"openmc\"\n    \"\"\"Name of converter\"\"\"\n    material_id: int | None = None\n    \"\"\"The id number or mat number used in OpenMC materials,\n    auto assigned by default within OpenMC.\"\"\"\n    packing_fraction: float = 1.0\n    \"\"\"Amount of unit packed volume of a material\"\"\"\n    percent_type: Literal[\"atomic\", \"mass\"] = \"atomic\"\n    \"\"\"Percent type of material\"\"\"\n    enrichment: float | None = None\n    \"\"\"Enrichment percent of the target\"\"\"\n    enrichment_target: str | None = None\n    \"\"\"Enrichment target for instance Li6\"\"\"\n    enrichment_type: Literal[\"atomic\", \"mass\"] | None = None\n    \"\"\"Enrichment percentage type\"\"\"\n    atoms_per_unit_cell: int | None = None\n    \"\"\"Number of atoms per unit cell, used in combination with volume_of_unit_cell for\n    density fallback calculation\"\"\"\n    volume_of_unit_cell: float | None = None\n    \"\"\"Volume of unit cell, used in combination with atoms_per_unit_cell for\n    density fallback calculation\"\"\"\n    number_of_atoms_in_sample: int | None = None\n    \"\"\"If a material is not specified with chemical formula\n    this number is used to calculate density with the unit cell fallback\"\"\"\n\n    def convert(\n        self,\n        material: Material,\n        op_cond: OpCondT,\n        *,\n        temperature_to_neutronics_code: bool = False,\n    ) -&gt; openmc.Material:\n        \"\"\"\n        Returns\n        -------\n        :\n            OpenMC material object\n\n        Raises\n        ------\n        ValueError\n            If density cannot be calculated from unit cell\n        \"\"\"\n        no_atoms = material.elements._no_atoms or self.number_of_atoms_in_sample  # noqa: SLF001\n        ef_dict = _to_fraction_conversion(self.percent_type, material.elements.root)\n        # Isotope-element separation\n        isotopes, elements = {}, {}\n        for k, v in ef_dict.items():\n            if isinstance(v.element.element, pt.core.Isotope):\n                isotopes[k] = v.fraction\n            else:\n                elements[k] = v.fraction\n\n        # density calculation from unit cell\n        if hasattr(material, \"density\"):\n            density = material.density.value_as(op_cond, \"g/cm^3\")\n        elif None not in {\n            no_atoms,\n            self.atoms_per_unit_cell,\n            self.volume_of_unit_cell,\n        }:\n            density = ureg.Quantity(\n                density_from_unit_cell(\n                    no_atoms,\n                    self.atoms_per_unit_cell,\n                    material.average_molar_mass,\n                    self.volume_of_unit_cell,\n                ),\n                \"kg/m^3\",\n            ).to(\"g/cm^3\")\n        else:\n            raise ValueError(\n                \"Density not provided and cannot be calculated from unit cell\"\n            )\n\n        return to_openmc_material(\n            name=material.name,\n            material_id=self.material_id,\n            temperature=_temp_check(\n                op_cond.temperature.value, temperature_to_neutronics_code\n            ),\n            density=density,\n            density_unit=\"g/cm^3\",\n            isotopes=isotopes or None,\n            elements=elements or None,\n            percent_type=self.percent_type,\n            enrichment=self.enrichment,\n            enrichment_target=self.enrichment_target,\n            enrichment_type=self.enrichment_type,\n            packing_fraction=self.packing_fraction,\n            temperature_to_neutronics_code=temperature_to_neutronics_code,\n        )\n</code></pre>"},{"location":"source/reference/matproplib/converters/neutronics/#matproplib.converters.neutronics.OpenMCNeutronicConfig.name","title":"<code>name = 'openmc'</code>  <code>class-attribute</code>","text":"<p>Name of converter</p>"},{"location":"source/reference/matproplib/converters/neutronics/#matproplib.converters.neutronics.OpenMCNeutronicConfig.material_id","title":"<code>material_id = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The id number or mat number used in OpenMC materials, auto assigned by default within OpenMC.</p>"},{"location":"source/reference/matproplib/converters/neutronics/#matproplib.converters.neutronics.OpenMCNeutronicConfig.packing_fraction","title":"<code>packing_fraction = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Amount of unit packed volume of a material</p>"},{"location":"source/reference/matproplib/converters/neutronics/#matproplib.converters.neutronics.OpenMCNeutronicConfig.percent_type","title":"<code>percent_type = 'atomic'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Percent type of material</p>"},{"location":"source/reference/matproplib/converters/neutronics/#matproplib.converters.neutronics.OpenMCNeutronicConfig.enrichment","title":"<code>enrichment = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Enrichment percent of the target</p>"},{"location":"source/reference/matproplib/converters/neutronics/#matproplib.converters.neutronics.OpenMCNeutronicConfig.enrichment_target","title":"<code>enrichment_target = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Enrichment target for instance Li6</p>"},{"location":"source/reference/matproplib/converters/neutronics/#matproplib.converters.neutronics.OpenMCNeutronicConfig.enrichment_type","title":"<code>enrichment_type = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Enrichment percentage type</p>"},{"location":"source/reference/matproplib/converters/neutronics/#matproplib.converters.neutronics.OpenMCNeutronicConfig.atoms_per_unit_cell","title":"<code>atoms_per_unit_cell = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of atoms per unit cell, used in combination with volume_of_unit_cell for density fallback calculation</p>"},{"location":"source/reference/matproplib/converters/neutronics/#matproplib.converters.neutronics.OpenMCNeutronicConfig.volume_of_unit_cell","title":"<code>volume_of_unit_cell = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Volume of unit cell, used in combination with atoms_per_unit_cell for density fallback calculation</p>"},{"location":"source/reference/matproplib/converters/neutronics/#matproplib.converters.neutronics.OpenMCNeutronicConfig.number_of_atoms_in_sample","title":"<code>number_of_atoms_in_sample = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If a material is not specified with chemical formula this number is used to calculate density with the unit cell fallback</p>"},{"location":"source/reference/matproplib/converters/neutronics/#matproplib.converters.neutronics.OpenMCNeutronicConfig.convert","title":"<code>convert(material, op_cond, *, temperature_to_neutronics_code=False)</code>","text":"<p>Returns:</p> Type Description <code>Material</code> <p>OpenMC material object</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If density cannot be calculated from unit cell</p> Source code in <code>matproplib/converters/neutronics.py</code> <pre><code>def convert(\n    self,\n    material: Material,\n    op_cond: OpCondT,\n    *,\n    temperature_to_neutronics_code: bool = False,\n) -&gt; openmc.Material:\n    \"\"\"\n    Returns\n    -------\n    :\n        OpenMC material object\n\n    Raises\n    ------\n    ValueError\n        If density cannot be calculated from unit cell\n    \"\"\"\n    no_atoms = material.elements._no_atoms or self.number_of_atoms_in_sample  # noqa: SLF001\n    ef_dict = _to_fraction_conversion(self.percent_type, material.elements.root)\n    # Isotope-element separation\n    isotopes, elements = {}, {}\n    for k, v in ef_dict.items():\n        if isinstance(v.element.element, pt.core.Isotope):\n            isotopes[k] = v.fraction\n        else:\n            elements[k] = v.fraction\n\n    # density calculation from unit cell\n    if hasattr(material, \"density\"):\n        density = material.density.value_as(op_cond, \"g/cm^3\")\n    elif None not in {\n        no_atoms,\n        self.atoms_per_unit_cell,\n        self.volume_of_unit_cell,\n    }:\n        density = ureg.Quantity(\n            density_from_unit_cell(\n                no_atoms,\n                self.atoms_per_unit_cell,\n                material.average_molar_mass,\n                self.volume_of_unit_cell,\n            ),\n            \"kg/m^3\",\n        ).to(\"g/cm^3\")\n    else:\n        raise ValueError(\n            \"Density not provided and cannot be calculated from unit cell\"\n        )\n\n    return to_openmc_material(\n        name=material.name,\n        material_id=self.material_id,\n        temperature=_temp_check(\n            op_cond.temperature.value, temperature_to_neutronics_code\n        ),\n        density=density,\n        density_unit=\"g/cm^3\",\n        isotopes=isotopes or None,\n        elements=elements or None,\n        percent_type=self.percent_type,\n        enrichment=self.enrichment,\n        enrichment_target=self.enrichment_target,\n        enrichment_type=self.enrichment_type,\n        packing_fraction=self.packing_fraction,\n        temperature_to_neutronics_code=temperature_to_neutronics_code,\n    )\n</code></pre>"},{"location":"source/reference/matproplib/converters/neutronics/#matproplib.converters.neutronics.FispactNeutronicConfig","title":"<code>FispactNeutronicConfig</code>","text":"<p>               Bases: <code>NeutronicConfig</code></p> <p>Fispact neutronic properties model</p> Source code in <code>matproplib/converters/neutronics.py</code> <pre><code>class FispactNeutronicConfig(NeutronicConfig):\n    \"\"\"Fispact neutronic properties model\"\"\"\n\n    name: ClassVar[Literal[\"fispact\"]] = \"fispact\"\n    \"\"\"Name of converter\"\"\"\n    volume: Volume\n    \"\"\"Volume of material provided\"\"\"\n    decimal_places: int = 8\n    \"\"\"Precision of the material card\"\"\"\n\n    def convert(\n        self,\n        material: Material,\n        op_cond: OpCondT,\n        *,\n        additional_end_lines: list[str] | None = None,\n    ) -&gt; str:\n        \"\"\"\n        Returns\n        -------\n        :\n            Fispact material card\n        \"\"\"\n        mass_density = _get_mass_density(material, op_cond)\n        isotopes = {}  # atoms/cm^3\n        for k, v in material.elements.nucleides:\n            pt_el = v.element.element\n            isotopes[k] = _atoms(v.fraction, mass_density, pt_el.mass)\n\n        return to_fispact_material(\n            self.volume.value_as(\"cm^3\"),\n            mass_density,\n            isotopes,\n            self.decimal_places,\n            additional_end_lines,\n        )\n</code></pre>"},{"location":"source/reference/matproplib/converters/neutronics/#matproplib.converters.neutronics.FispactNeutronicConfig.name","title":"<code>name = 'fispact'</code>  <code>class-attribute</code>","text":"<p>Name of converter</p>"},{"location":"source/reference/matproplib/converters/neutronics/#matproplib.converters.neutronics.FispactNeutronicConfig.volume","title":"<code>volume</code>  <code>instance-attribute</code>","text":"<p>Volume of material provided</p>"},{"location":"source/reference/matproplib/converters/neutronics/#matproplib.converters.neutronics.FispactNeutronicConfig.decimal_places","title":"<code>decimal_places = 8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Precision of the material card</p>"},{"location":"source/reference/matproplib/converters/neutronics/#matproplib.converters.neutronics.FispactNeutronicConfig.convert","title":"<code>convert(material, op_cond, *, additional_end_lines=None)</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>Fispact material card</p> Source code in <code>matproplib/converters/neutronics.py</code> <pre><code>def convert(\n    self,\n    material: Material,\n    op_cond: OpCondT,\n    *,\n    additional_end_lines: list[str] | None = None,\n) -&gt; str:\n    \"\"\"\n    Returns\n    -------\n    :\n        Fispact material card\n    \"\"\"\n    mass_density = _get_mass_density(material, op_cond)\n    isotopes = {}  # atoms/cm^3\n    for k, v in material.elements.nucleides:\n        pt_el = v.element.element\n        isotopes[k] = _atoms(v.fraction, mass_density, pt_el.mass)\n\n    return to_fispact_material(\n        self.volume.value_as(\"cm^3\"),\n        mass_density,\n        isotopes,\n        self.decimal_places,\n        additional_end_lines,\n    )\n</code></pre>"},{"location":"source/reference/matproplib/converters/neutronics/#matproplib.converters.neutronics.MCNPNeutronicConfig","title":"<code>MCNPNeutronicConfig</code>","text":"<p>               Bases: <code>NeutronicConfig</code></p> <p>MCNP6 neutronic properties model</p> Source code in <code>matproplib/converters/neutronics.py</code> <pre><code>class MCNPNeutronicConfig(NeutronicConfig):\n    \"\"\"MCNP6 neutronic properties model\"\"\"\n\n    name: ClassVar[Literal[\"mcnp\"]] = \"mcnp\"\n    \"\"\"Name of converter\"\"\"\n    zaid_suffix: str = \"\"\n    \"\"\"The nuclear library to apply to the zaid, for example \".31c\", this is used in\n        MCNP and Serpent material cards.\"\"\"\n    material_id: int | None = None\n    \"\"\"The id number or mat number used in the MCNP and OpenMC material cards.\"\"\"\n    decimal_places: int = 8\n    percent_type: Literal[\"atomic\", \"mass\"] = \"atomic\"\n\n    def convert(\n        self,\n        material: Material,\n        op_cond: OpCondT,\n        *,\n        additional_end_lines: list[str] | None = None,\n    ) -&gt; str:\n        \"\"\"\n        Returns\n        -------\n        :\n            MCNP material card\n        \"\"\"\n        ef_dict = _to_fraction_conversion(\n            self.percent_type, material.elements.nucleides.root\n        )\n\n        mass_density = _get_mass_density(material, op_cond)\n        if self.material_id is None:\n            mat_id = global_id[\"mcnp\"]\n            global_id[\"mcnp\"] += 1\n        else:\n            mat_id = self.material_id\n\n        nucleides: list[tuple[ElementFraction, Literal[\"mass\", \"atomic\"]]] = [\n            (v, self.percent_type) for _k, v in ef_dict.items()\n        ]\n\n        return to_mcnp_material(\n            mat_id,\n            mass_density,\n            nucleides,\n            material.name,\n            self.zaid_suffix,\n            self.decimal_places,\n            additional_end_lines,\n        )\n</code></pre>"},{"location":"source/reference/matproplib/converters/neutronics/#matproplib.converters.neutronics.MCNPNeutronicConfig.name","title":"<code>name = 'mcnp'</code>  <code>class-attribute</code>","text":"<p>Name of converter</p>"},{"location":"source/reference/matproplib/converters/neutronics/#matproplib.converters.neutronics.MCNPNeutronicConfig.zaid_suffix","title":"<code>zaid_suffix = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The nuclear library to apply to the zaid, for example \".31c\", this is used in MCNP and Serpent material cards.</p>"},{"location":"source/reference/matproplib/converters/neutronics/#matproplib.converters.neutronics.MCNPNeutronicConfig.material_id","title":"<code>material_id = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The id number or mat number used in the MCNP and OpenMC material cards.</p>"},{"location":"source/reference/matproplib/converters/neutronics/#matproplib.converters.neutronics.MCNPNeutronicConfig.decimal_places","title":"<code>decimal_places = 8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/converters/neutronics/#matproplib.converters.neutronics.MCNPNeutronicConfig.percent_type","title":"<code>percent_type = 'atomic'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/converters/neutronics/#matproplib.converters.neutronics.MCNPNeutronicConfig.convert","title":"<code>convert(material, op_cond, *, additional_end_lines=None)</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>MCNP material card</p> Source code in <code>matproplib/converters/neutronics.py</code> <pre><code>def convert(\n    self,\n    material: Material,\n    op_cond: OpCondT,\n    *,\n    additional_end_lines: list[str] | None = None,\n) -&gt; str:\n    \"\"\"\n    Returns\n    -------\n    :\n        MCNP material card\n    \"\"\"\n    ef_dict = _to_fraction_conversion(\n        self.percent_type, material.elements.nucleides.root\n    )\n\n    mass_density = _get_mass_density(material, op_cond)\n    if self.material_id is None:\n        mat_id = global_id[\"mcnp\"]\n        global_id[\"mcnp\"] += 1\n    else:\n        mat_id = self.material_id\n\n    nucleides: list[tuple[ElementFraction, Literal[\"mass\", \"atomic\"]]] = [\n        (v, self.percent_type) for _k, v in ef_dict.items()\n    ]\n\n    return to_mcnp_material(\n        mat_id,\n        mass_density,\n        nucleides,\n        material.name,\n        self.zaid_suffix,\n        self.decimal_places,\n        additional_end_lines,\n    )\n</code></pre>"},{"location":"source/reference/matproplib/converters/neutronics/#matproplib.converters.neutronics.SerpentNeutronicConfig","title":"<code>SerpentNeutronicConfig</code>","text":"<p>               Bases: <code>NeutronicConfig</code></p> <p>Serpent neutronic properties model</p> Source code in <code>matproplib/converters/neutronics.py</code> <pre><code>class SerpentNeutronicConfig(NeutronicConfig):\n    \"\"\"Serpent neutronic properties model\"\"\"\n\n    name: ClassVar[Literal[\"serpent\"]] = \"serpent\"\n    \"\"\"Name of converter\"\"\"\n    zaid_suffix: str = \"\"\n    \"\"\"The nuclear library to apply to the zaid, for example \".31c\", this is used in\n        MCNP and Serpent material cards.\"\"\"\n    decimal_places: int = 8\n    percent_type: Literal[\"atomic\", \"mass\"] = \"atomic\"\n\n    def convert(\n        self,\n        material: Material,\n        op_cond: OpCondT,\n        *,\n        additional_end_lines: list[str] | None = None,\n        temperature_to_neutronics_code: bool = False,\n    ) -&gt; str:\n        \"\"\"\n        Returns\n        -------\n        :\n            Serpent material card\n        \"\"\"\n        ef_dict = _to_fraction_conversion(\n            self.percent_type, material.elements.nucleides.root\n        )\n        mass_density = _get_mass_density(material, op_cond)\n        nucleides: list[tuple[ElementFraction, Literal[\"mass\", \"atomic\"]]] = [\n            (v, self.percent_type) for _k, v in ef_dict.items()\n        ]\n\n        return to_serpent_material(\n            material.name,\n            mass_density,\n            nucleides,\n            _temp_check(op_cond.temperature.value, temperature_to_neutronics_code),\n            self.decimal_places,\n            self.zaid_suffix,\n            additional_end_lines,\n            temperature_to_neutronics_code=temperature_to_neutronics_code,\n        )\n</code></pre>"},{"location":"source/reference/matproplib/converters/neutronics/#matproplib.converters.neutronics.SerpentNeutronicConfig.name","title":"<code>name = 'serpent'</code>  <code>class-attribute</code>","text":"<p>Name of converter</p>"},{"location":"source/reference/matproplib/converters/neutronics/#matproplib.converters.neutronics.SerpentNeutronicConfig.zaid_suffix","title":"<code>zaid_suffix = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The nuclear library to apply to the zaid, for example \".31c\", this is used in MCNP and Serpent material cards.</p>"},{"location":"source/reference/matproplib/converters/neutronics/#matproplib.converters.neutronics.SerpentNeutronicConfig.decimal_places","title":"<code>decimal_places = 8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/converters/neutronics/#matproplib.converters.neutronics.SerpentNeutronicConfig.percent_type","title":"<code>percent_type = 'atomic'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/converters/neutronics/#matproplib.converters.neutronics.SerpentNeutronicConfig.convert","title":"<code>convert(material, op_cond, *, additional_end_lines=None, temperature_to_neutronics_code=False)</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>Serpent material card</p> Source code in <code>matproplib/converters/neutronics.py</code> <pre><code>def convert(\n    self,\n    material: Material,\n    op_cond: OpCondT,\n    *,\n    additional_end_lines: list[str] | None = None,\n    temperature_to_neutronics_code: bool = False,\n) -&gt; str:\n    \"\"\"\n    Returns\n    -------\n    :\n        Serpent material card\n    \"\"\"\n    ef_dict = _to_fraction_conversion(\n        self.percent_type, material.elements.nucleides.root\n    )\n    mass_density = _get_mass_density(material, op_cond)\n    nucleides: list[tuple[ElementFraction, Literal[\"mass\", \"atomic\"]]] = [\n        (v, self.percent_type) for _k, v in ef_dict.items()\n    ]\n\n    return to_serpent_material(\n        material.name,\n        mass_density,\n        nucleides,\n        _temp_check(op_cond.temperature.value, temperature_to_neutronics_code),\n        self.decimal_places,\n        self.zaid_suffix,\n        additional_end_lines,\n        temperature_to_neutronics_code=temperature_to_neutronics_code,\n    )\n</code></pre>"},{"location":"source/reference/matproplib/library/beryllium/","title":"beryllium","text":"<p>Beryllium materials</p>"},{"location":"source/reference/matproplib/library/beryllium/#matproplib.library.beryllium.Be12Ti","title":"<code>Be12Ti = material('Be12Ti', elements='Be12Ti', converters=(OpenMCNeutronicConfig(volume_of_unit_cell=2.2724e-28, atoms_per_unit_cell=2, enrichment_target='Li6', enrichment_type='atomic')), properties=(props(as_field=True, density=(Density.from_unit_cell()))))</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/beryllium/#matproplib.library.beryllium.BP_SHC","title":"<code>BP_SHC = From1DData([0, 50, 100, 150, 200, 250, 300, 350, 400, 450, 500, 550, 600, 650, 700, 750, 800, 850, 900, 950, 1000], [1741.8, 1900.97, 2045.53, 2176.44, 2294.66, 2401.14, 2496.83, 2582.71, 2659.71, 2728.79, 2790.93, 2847.05, 2898.14, 2945.13, 2988.99, 3030.68, 3071.14, 3111.34, 3152.22, 3194.76, 3239.9], 'temperature')</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/beryllium/#matproplib.library.beryllium.BePebbleBed","title":"<code>BePebbleBed = material('BePebbleBed', elements='Be', properties=(props(as_field=True, specific_heat_capacity=BePB_specific_heat_capacity, coefficient_thermal_expansion=BePB_CTE)), converters=(OpenMCNeutronicConfig(volume_of_unit_cell=1.622e-29, atoms_per_unit_cell=8)))</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/beryllium/#matproplib.library.beryllium.BePB_CTE","title":"<code>BePB_CTE(op_cond)</code>","text":"<p>.. doi:: 10.1016/S0920-3796(02)00165-5</p> <p>Returns:</p> Type Description <code>float</code> <p>Mean coefficient of thermal expansion</p> Source code in <code>matproplib/library/beryllium.py</code> <pre><code>@dependentphysicalproperty(\n    CoefficientThermalExpansion,\n    unit=\"1e-6/K\",\n    op_cond_config={\"temperature\": (\"degC\", 25, 800)},\n    reference={\n        \"id\": \"bepb_cte\",\n        \"type\": \"article\",\n        \"doi\": \"10.1016/S0920-3796(02)00165-5\",\n    },\n)\ndef BePB_CTE(op_cond: OpCondT) -&gt; float:\n    \"\"\"\n    .. doi:: 10.1016/S0920-3796(02)00165-5\n\n    Returns\n    -------\n    :\n        Mean coefficient of thermal expansion\n    \"\"\"\n    # NOTE: Effect of inelastic volumetric strains [%] not negligible\n    # eps_vol calculated roughly as f(T), as per 2M2BH9\n    eps_vol = op_cond.strain\n    if eps_vol == 0:\n\n        def calc_eps_vol(temp):\n            \"\"\"\n            Returns\n            -------\n            :\n                Inelastic volumetric strains [%] based on T (C)\n            \"\"\"\n            if temp &gt;= 600:  # noqa: PLR2004\n                return 0.5\n            if temp &gt;= 500:  # noqa: PLR2004\n                return 0.3\n            if temp &lt; 500:  # noqa: PLR2004\n                return 0.2\n            return None\n\n        eps_vol = np.vectorize(calc_eps_vol)(op_cond.temperature)\n    eps_vol *= np.ones_like(op_cond.temperature)\n    return (\n        1.81\n        + 0.0012 * op_cond.temperature\n        - 5e-7 * op_cond.temperature**2\n        + eps_vol\n        * (\n            9.03\n            - 1.386e-3 * op_cond.temperature\n            - 7.6e-6 * op_cond.temperature**2\n            + 2.1e-9 * op_cond.temperature**3\n        )\n    )\n</code></pre>"},{"location":"source/reference/matproplib/library/beryllium/#matproplib.library.beryllium.BePB_specific_heat_capacity","title":"<code>BePB_specific_heat_capacity(op_cond)</code>","text":"Source code in <code>matproplib/library/beryllium.py</code> <pre><code>@dependentphysicalproperty(\n    dpp=SpecificHeatCapacity,\n    op_cond_config={\"temperature\": (\"degC\", 0, 1000)},\n    reference=FOKKENS_2003,\n)\ndef BePB_specific_heat_capacity(op_cond: OpCondT):\n    return BP_SHC(op_cond)\n</code></pre>"},{"location":"source/reference/matproplib/library/concrete/","title":"concrete","text":"<p>Concrete materials</p>"},{"location":"source/reference/matproplib/library/concrete/#matproplib.library.concrete.Concrete","title":"<code>Concrete = material('Concrete', elements={'H': 0.00453, 'O': 0.5126, 'Na': 0.01527, 'Al': 0.03555, 'Si': 0.36036, 'Ca': 0.05791, 'Fe': 0.01378}, properties=(props(as_field=True, density=2250, poissons_ratio=0.33)), converters=(OpenMCNeutronicConfig()))</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/concrete/#matproplib.library.concrete.OrdinaryConcrete","title":"<code>OrdinaryConcrete = material('OrdinaryConcrete', elements={'H': 0.0055, 'O': 0.4975, 'Si': 0.3147, 'Ca': 0.0828, 'Mg': 0.0026, 'Al': 0.0469, 'S': 0.0013, 'Fe': 0.0124, 'Na': 0.0171, 'K': 0.0192}, properties=(props(as_field=True, density=2200, poissons_ratio=0.33)), converters=(OpenMCNeutronicConfig()))</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/concrete/#matproplib.library.concrete.HeavyConcrete","title":"<code>HeavyConcrete = material('HeavyConcrete', elements={'H': 0.0052, 'O': 0.3273, 'C': 0.004, 'Si': 0.0224, 'Ca': 0.0657, 'Mg': 0.0021, 'Al': 0.0038, 'Fe': 0.568, 'P': 0.0015}, properties=(props(as_field=True, density=3600, poissons_ratio=0.33)), converters=(OpenMCNeutronicConfig()))</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/copper/","title":"copper","text":"<p>Copper materials</p>"},{"location":"source/reference/matproplib/library/copper/#matproplib.library.copper.Bronze","title":"<code>Bronze</code>","text":"<p>               Bases: <code>FullMaterial</code></p> <p>Simple Bronze Material</p> Source code in <code>matproplib/library/copper.py</code> <pre><code>@rebuild\nclass Bronze(FullMaterial):\n    \"\"\"Simple Bronze Material\"\"\"\n\n    name: str = Field(default=\"Bronze\")\n    elements: Elements = Field(default={\"Cu\": 0.95, \"Sn\": 0.05})\n    properties: PropertiesT_co = props(\n        as_field=True, density=8877.5, poissons_ratio=0.33\n    )\n\n    converters: Converters = Field(\n        default_factory=lambda: OpenMCNeutronicConfig(\n            percent_type=\"atomic\",\n        )\n    )\n</code></pre>"},{"location":"source/reference/matproplib/library/copper/#matproplib.library.copper.Bronze.name","title":"<code>name = Field(default='Bronze')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/library/copper/#matproplib.library.copper.Bronze.elements","title":"<code>elements = Field(default={'Cu': 0.95, 'Sn': 0.05})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/library/copper/#matproplib.library.copper.Bronze.properties","title":"<code>properties = props(as_field=True, density=8877.5, poissons_ratio=0.33)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/library/copper/#matproplib.library.copper.Bronze.converters","title":"<code>converters = Field(default_factory=(lambda: OpenMCNeutronicConfig(percent_type='atomic')))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/library/copper/#matproplib.library.copper.CryogenicCopper","title":"<code>CryogenicCopper</code>","text":"<p>               Bases: <code>FullMaterial</code></p> <p>High-purity cryogenic copper, NIST properties</p> Source code in <code>matproplib/library/copper.py</code> <pre><code>@rebuild\nclass CryogenicCopper(FullMaterial):\n    \"\"\"High-purity cryogenic copper, NIST properties\"\"\"\n\n    name: str = \"CryogenicCopper\"\n    elements: Elements = Field(\n        default={\n            \"Cu\": 0.999964,\n            \"Ag\": 0.000011,\n            \"Pb\": 0.000002,\n            \"S\": 0.000011,\n            \"Se\": 0.000001,\n            \"Ni\": 0.000011,\n            \"fraction_type\": \"mass\",\n        },\n    )\n    properties: PropertiesT_co = props(\n        as_field=True,\n        poissons_ratio=_copper_poisson_ratio,\n        residual_resistance_ratio=100.0,\n        youngs_modulus=_copper_youngs_modulus,\n        shear_modulus=_copper_shear_modulus,\n        bulk_modulus=_copper_bulk_modulus,\n        specific_heat_capacity=_copper_specific_heat_capacity,\n        thermal_conductivity=_copper_thermal_conductivity,\n        coefficient_thermal_expansion=_copper_thermal_expansion_coefficient,\n        electrical_resistivity=_copper_electrical_resistivity,\n        magnetic_susceptibility=_copper_magnetic_susceptibility,\n    )\n    converters: Converters = Field(\n        default_factory=lambda: OpenMCNeutronicConfig(\n            percent_type=\"atomic\",\n        )\n    )\n    reference: References = SIMON_1992\n</code></pre>"},{"location":"source/reference/matproplib/library/copper/#matproplib.library.copper.CryogenicCopper.name","title":"<code>name = 'CryogenicCopper'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/library/copper/#matproplib.library.copper.CryogenicCopper.elements","title":"<code>elements = Field(default={'Cu': 0.999964, 'Ag': 1.1e-05, 'Pb': 2e-06, 'S': 1.1e-05, 'Se': 1e-06, 'Ni': 1.1e-05, 'fraction_type': 'mass'})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/library/copper/#matproplib.library.copper.CryogenicCopper.properties","title":"<code>properties = props(as_field=True, poissons_ratio=_copper_poisson_ratio, residual_resistance_ratio=100.0, youngs_modulus=_copper_youngs_modulus, shear_modulus=_copper_shear_modulus, bulk_modulus=_copper_bulk_modulus, specific_heat_capacity=_copper_specific_heat_capacity, thermal_conductivity=_copper_thermal_conductivity, coefficient_thermal_expansion=_copper_thermal_expansion_coefficient, electrical_resistivity=_copper_electrical_resistivity, magnetic_susceptibility=_copper_magnetic_susceptibility)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/library/copper/#matproplib.library.copper.CryogenicCopper.converters","title":"<code>converters = Field(default_factory=(lambda: OpenMCNeutronicConfig(percent_type='atomic')))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/library/copper/#matproplib.library.copper.CryogenicCopper.reference","title":"<code>reference = SIMON_1992</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/library/fluids/","title":"fluids","text":"<p>Fluid materials</p>"},{"location":"source/reference/matproplib/library/fluids/#matproplib.library.fluids.DTPlasma","title":"<code>DTPlasma = material('DTPlasma', elements={'H2': 0.5, 'H3': 0.5}, properties=(props(as_field=True, density=(Density(value=1e-06, unit='g/cm^3')), youngs_modulus=0, poissons_ratio=0)), converters=(OpenMCNeutronicConfig()))</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/fluids/#matproplib.library.fluids.DDPlasma","title":"<code>DDPlasma = material('DDPlasma', elements={'H2': 1}, properties=(props(as_field=True, density=(Density(value=1e-06, unit='g/cm^3')), youngs_modulus=0, poissons_ratio=0)), converters=(OpenMCNeutronicConfig()))</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/fluids/#matproplib.library.fluids.Water","title":"<code>Water = material('Water (liquid to gas)', elements='H2O', properties=(props(as_field=True, density=(Density(value=(lambda oc: PropsSI('DMASS', 'T', oc.temperature.value, 'P', oc.pressure.value, 'Water')), op_cond_config={'temperature': ('K', 273.153)})), specific_heat_capacity=(SpecificHeatCapacity(value=(lambda oc: PropsSI('CPMASS', 'T', oc.temperature.value, 'P', oc.pressure.value, 'Water')), op_cond_config={'temperature': ('K', 273.153)})), thermal_conductivity=(ThermalConductivity(value=(lambda oc: PropsSI('CONDUCTIVITY', 'T', oc.temperature.value, 'P', oc.pressure.value, 'Water')), op_cond_config={'temperature': ('K', 273.153)})), youngs_modulus=0, bulk_modulus=0, shear_modulus=0, poissons_ratio=0, minimum_yield_stress=0, average_yield_stress=0, minimum_ultimate_tensile_stress=0, average_ultimate_tensile_stress=0)), converters=(OpenMCNeutronicConfig()), reference=COOLPROP_7)</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/fluids/#matproplib.library.fluids.Air","title":"<code>Air = material('Air (gas)', elements={'N': 2 * 0.78 / 1.99, 'O': 2 * 0.21 / 1.99, 'Ar': 0.01 / 1.99, 'fraction_type': 'atomic'}, properties=(props(as_field=True, density=(Density(value=(lambda oc: PropsSI('DMASS', 'T', oc.temperature.value, 'P', oc.pressure.value, 'Air')), op_cond_config={'temperature': ('K', 59.75)})), specific_heat_capacity=(SpecificHeatCapacity(value=(lambda oc: PropsSI('CPMASS', 'T', oc.temperature.value, 'P', oc.pressure.value, 'Air')), op_cond_config={'temperature': ('K', 59.75)})), thermal_conductivity=(ThermalConductivity(value=(lambda oc: PropsSI('CONDUCTIVITY', 'T', oc.temperature.value, 'P', oc.pressure.value, 'Air')), op_cond_config={'temperature': ('K', 59.75)})), youngs_modulus=0, bulk_modulus=0, shear_modulus=0, poissons_ratio=0, minimum_yield_stress=0, average_yield_stress=0, minimum_ultimate_tensile_stress=0, average_ultimate_tensile_stress=0)), converters=(OpenMCNeutronicConfig()), reference=COOLPROP_7)</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/fluids/#matproplib.library.fluids.Hydrogen","title":"<code>Hydrogen = material('Hydrogen (liquid to gas)', elements='H', properties=(props(as_field=True, density=(Density(value=(lambda oc: PropsSI('D', 'T', oc.temperature.value, 'P', oc.pressure.value, 'Hydrogen')), op_cond_config={'temperature': ('K', 1.66685)})), specific_heat_capacity=(SpecificHeatCapacity(value=(lambda oc: PropsSI('CPMASS', 'T', oc.temperature.value, 'P', oc.pressure.value, 'Hydrogen')), op_cond_config={'temperature': ('K', 1.66685)})), thermal_conductivity=(ThermalConductivity(value=(lambda oc: PropsSI('CONDUCTIVITY', 'T', oc.temperature.value, 'P', oc.pressure.value, 'Hydrogen')), op_cond_config={'temperature': ('K', 1.66685)})), youngs_modulus=0, bulk_modulus=0, shear_modulus=0, poissons_ratio=0, minimum_yield_stress=0, average_yield_stress=0, minimum_ultimate_tensile_stress=0, average_ultimate_tensile_stress=0)), converters=(OpenMCNeutronicConfig()), reference=COOLPROP_7)</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/fluids/#matproplib.library.fluids.Helium","title":"<code>Helium = material('Helium (liquid to gas)', elements='He', properties=(props(as_field=True, density=(Density(value=(lambda oc: PropsSI('D', 'T', oc.temperature.value, 'P', oc.pressure.value, 'Helium')), op_cond_config={'temperature': ('K', 1.58842)})), specific_heat_capacity=(SpecificHeatCapacity(value=(lambda oc: PropsSI('CPMASS', 'T', oc.temperature.value, 'P', oc.pressure.value, 'Helium')), op_cond_config={'temperature': ('K', 1.58842)})), thermal_conductivity=(ThermalConductivity(value=(lambda oc: PropsSI('CONDUCTIVITY', 'T', oc.temperature.value, 'P', oc.pressure.value, 'Helium')), op_cond_config={'temperature': ('K', 1.58842)})), youngs_modulus=0, bulk_modulus=0, shear_modulus=0, poissons_ratio=0, minimum_yield_stress=0, average_yield_stress=0, minimum_ultimate_tensile_stress=0, average_ultimate_tensile_stress=0)), converters=(OpenMCNeutronicConfig()), reference=COOLPROP_7)</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/fluids/#matproplib.library.fluids.Void","title":"<code>Void</code>","text":"<p>               Bases: <code>FullMaterial</code></p> <p>Material for a void, very low hydrogen concentration</p> Source code in <code>matproplib/library/fluids.py</code> <pre><code>class Void(FullMaterial):\n    \"\"\"Material for a void, very low hydrogen concentration\"\"\"\n\n    name: str = Field(default=\"Void\")\n    elements: Elements = Field(default=[\"H\"], frozen=True)\n    density: Density = Field(\n        default=Density.from_nuclear_units({\"H\": 1}, 1),\n        frozen=True,\n    )\n    converters: Converters = Field(\n        default_factory=lambda: OpenMCNeutronicConfig(\n            percent_type=\"atomic\",\n        )\n    )\n</code></pre>"},{"location":"source/reference/matproplib/library/fluids/#matproplib.library.fluids.Void.name","title":"<code>name = Field(default='Void')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/library/fluids/#matproplib.library.fluids.Void.elements","title":"<code>elements = Field(default=['H'], frozen=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/library/fluids/#matproplib.library.fluids.Void.density","title":"<code>density = Field(default=(Density.from_nuclear_units({'H': 1}, 1)), frozen=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/library/fluids/#matproplib.library.fluids.Void.converters","title":"<code>converters = Field(default_factory=(lambda: OpenMCNeutronicConfig(percent_type='atomic')))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/library/lithium/","title":"lithium","text":"<p>Lithium materials</p>"},{"location":"source/reference/matproplib/library/lithium/#matproplib.library.lithium.PbLi_eutectic","title":"<code>PbLi_eutectic = material('PbLi_eutectic', elements={'Pb': 0.99283, 'Li': 0.0062, 'Ag': 1e-05, 'Cu': 1e-05, 'Nb': 1e-05, 'Pd': 1e-05, 'Zn': 1e-05, 'Fe': 5e-05, 'Cr': 5e-05, 'Mn': 5e-05, 'Mo': 5e-05, 'Ni': 5e-05, 'V': 5e-05, 'Si': 0.0001, 'Al': 0.0001, 'Bi': 0.0002, 'Sn': 0.0002, 'W': 2e-05}, properties=(props(as_field=True, density=10000, poissons_ratio=0.33)))</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/lithium/#matproplib.library.lithium.Li4SO4_SHC","title":"<code>Li4SO4_SHC = From1DData([0, 50, 100, 150, 200, 250, 300, 350, 400, 450, 500, 550, 600, 650, 700, 750, 800, 850, 900, 950, 1000], [1392.4, 1450, 1513.4, 1580, 1648.5, 1718.2, 1788.8, 1859.9, 1931.4, 2003.3, 2075.3, 2147.5, 2219.8, 2292.3, 2364.8, 2437.4, 2510.1, 2582.8, 2655.5, 2728.3, 2801.1], 'temperature')</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/lithium/#matproplib.library.lithium.Li4SiO4","title":"<code>Li4SiO4 = material('Li4SiO4', elements='Li4SiO4', properties=(props(as_field=True, specific_heat_capacity=Li4SiO4_specific_heat_capacity, coefficient_thermal_expansion=(CoefficientThermalExpansion(value=(lambda oc: 0.768 + 0.000496 * oc.temperature + 0.045 * oc.strain), unit='1e-6/K', op_cond_config={'temperature': ('degC', 25, 800)}, reference={'id': 'liso4_cte', 'type': 'article', 'doi': '10.1016/S0920-3796(02)00165-5'})), density=(Density.from_unit_cell()))), converters=(OpenMCNeutronicConfig(volume_of_unit_cell=1.1543e-27, atoms_per_unit_cell=14, enrichment_target='Li6', enrichment_type='atomic')))</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/lithium/#matproplib.library.lithium.Li2SiO3","title":"<code>Li2SiO3 = material('Li2SiO3', elements='Li2SiO3', converters=(OpenMCNeutronicConfig(volume_of_unit_cell=2.3632e-28, atoms_per_unit_cell=4, enrichment_target='Li6', enrichment_type='atomic')), properties=(props(as_field=True, density=(Density.from_unit_cell()))), reference={'id': 'liso3_cell', 'type': 'article', 'doi': '10.1016/j.ssi.2019.02.019'})</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/lithium/#matproplib.library.lithium.Li2ZrO3","title":"<code>Li2ZrO3 = material('Li2ZrO3', elements='Li2ZrO3', converters=(OpenMCNeutronicConfig(volume_of_unit_cell=2.4479e-28, atoms_per_unit_cell=4, enrichment_target='Li6', enrichment_type='atomic')), properties=(props(as_field=True, density=(Density.from_unit_cell()))))</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/lithium/#matproplib.library.lithium.Li2TiO3","title":"<code>Li2TiO3 = material('Li2TiO3', elements='Li2TiO3', converters=(OpenMCNeutronicConfig(volume_of_unit_cell=4.2701e-28, atoms_per_unit_cell=8, enrichment_target='Li6', enrichment_type='atomic')), properties=(props(as_field=True, density=(Density.from_unit_cell()))))</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/lithium/#matproplib.library.lithium.Li4SiO4_specific_heat_capacity","title":"<code>Li4SiO4_specific_heat_capacity(op_cond)</code>","text":"<p>Specific heat capacity of LiSiO4</p> Source code in <code>matproplib/library/lithium.py</code> <pre><code>@dependentphysicalproperty(\n    dpp=SpecificHeatCapacity,\n    op_cond_config={\"temperature\": (\"degC\", 0, 1000)},\n    reference=FOKKENS_2003,\n)\ndef Li4SiO4_specific_heat_capacity(op_cond):\n    \"\"\"Specific heat capacity of LiSiO4\"\"\"  # noqa: DOC201\n    return Li4SO4_SHC(op_cond)\n</code></pre>"},{"location":"source/reference/matproplib/library/polymers/","title":"polymers","text":"<p>Polymer materials</p>"},{"location":"source/reference/matproplib/library/polymers/#matproplib.library.polymers.EpoxyResin","title":"<code>EpoxyResin</code>","text":"<p>               Bases: <code>FullMaterial</code></p> <p>Epoxy resin</p> Source code in <code>matproplib/library/polymers.py</code> <pre><code>@rebuild\nclass EpoxyResin(FullMaterial):\n    \"\"\"Epoxy resin\"\"\"\n\n    name: str = Field(default=\"EpoxyResin\")\n    elements: Elements = Field(\n        default={\n            \"Al\": 0.0007074,\n            \"C\": 0.0034056,\n            \"H\": 0.0038934,\n            \"Mg\": 0.0002142004,\n            \"N\": 0.0003708,\n            \"O\": 0.0048708,\n            \"S\": 9.179996e-5,\n            \"Si\": 0.0058552,\n        },\n    )\n    properties: PropertiesT_co = props(\n        as_field=True,\n        density=1207,\n        youngs_modulus={\n            \"value\": 7.5,\n            \"unit\": \"GPa\",\n            \"reference\": {\n                \"id\": \"ym_epoxy\",\n                \"type\": \"webpage\",\n                \"doi\": \"10.1109/20.511486\",\n                \"url\": r\"https://ncsx.pppl.gov/NCSX_Engineering/ModCoil_TF-Coil_VVSA_Fab/TF%20Coil%20Fabrication/Insulation%20Systems/Coil%20Papers%20from%20Neumeyer/Mech_Prop_Solenoids.pdf\",\n            },\n        },\n        poissons_ratio=0.33,\n    )\n    converters: Converters = Field(\n        default_factory=lambda: OpenMCNeutronicConfig(\n            percent_type=\"atomic\",\n        )\n    )\n</code></pre>"},{"location":"source/reference/matproplib/library/polymers/#matproplib.library.polymers.EpoxyResin.name","title":"<code>name = Field(default='EpoxyResin')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/library/polymers/#matproplib.library.polymers.EpoxyResin.elements","title":"<code>elements = Field(default={'Al': 0.0007074, 'C': 0.0034056, 'H': 0.0038934, 'Mg': 0.0002142004, 'N': 0.0003708, 'O': 0.0048708, 'S': 9.179996e-05, 'Si': 0.0058552})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/library/polymers/#matproplib.library.polymers.EpoxyResin.properties","title":"<code>properties = props(as_field=True, density=1207, youngs_modulus={'value': 7.5, 'unit': 'GPa', 'reference': {'id': 'ym_epoxy', 'type': 'webpage', 'doi': '10.1109/20.511486', 'url': 'https://ncsx.pppl.gov/NCSX_Engineering/ModCoil_TF-Coil_VVSA_Fab/TF%20Coil%20Fabrication/Insulation%20Systems/Coil%20Papers%20from%20Neumeyer/Mech_Prop_Solenoids.pdf'}}, poissons_ratio=0.33)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/library/polymers/#matproplib.library.polymers.EpoxyResin.converters","title":"<code>converters = Field(default_factory=(lambda: OpenMCNeutronicConfig(percent_type='atomic')))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/library/references/","title":"references","text":"<p>References for matproplib library</p>"},{"location":"source/reference/matproplib/library/references/#matproplib.library.references.FOKKENS_2003","title":"<code>FOKKENS_2003 = {'id': 'fokkens2003', 'type': 'report', 'author': [{'family': 'Fokkens, J. H.'}], 'title': 'Thermomechanical finite element analysis of the HCPB in-pile test element', 'event_date': {'raw': '2003'}, 'annote': 'NRG Report 21477/02.50560/P. Technical Report, TW0-TTBB-004-D1,'}</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/references/#matproplib.library.references.CORATO_2016","title":"<code>CORATO_2016 = {'id': 'corato2016', 'type': 'report', 'author': [{'family': 'V. Corato, R. Bonifetto, P. Bruzzone, D. Ciazynski, M. Coleman, E. Gaio, R. Heller, B. Lacroix, M. Lewandowska, A. Maistrello, L. Muzzi, S. Nicollet, A. Nijhuis, F. Nunio, A. Panin, L. Savoldi, K. Sedlak, A. Torre, S. Turtu, R. Vallcorba, R. Wesche, L. Zani, R. Zanino'}], 'title': 'Common operating values for DEMO magnets design for 2016', 'event_date': {'raw': '2016'}, 'annote': 'MEMO for WPMAG-MCD-2.1, version 1.4, EFDA_D_2MMDTG', 'url': 'https://scipub.euro-fusion.org/wp-content/uploads/eurofusion/WPMAGREP16_16565_submitted.pdf'}</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/references/#matproplib.library.references.FERRACIN_2022","title":"<code>FERRACIN_2022 = {'id': 'ferracin2022', 'type': 'event', 'author': [{'family': 'Ferracin, P., Marchevsky, M, Todesco, E.'}], 'title': 'Unit 9 and 10 Practical superconductors for accelerator magnets', 'event_date': {'raw': '2022'}, 'annote': 'Superconducting Accelerator Magnets, June 20 - July 1, 2022'}</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/references/#matproplib.library.references.BAUER_2007","title":"<code>BAUER_2007 = {'id': 'bauer2007', 'type': 'report', 'author': [{'family': 'Bauer, P., Rajainmaki, H., Salpietro, E.'}], 'title': 'EFDA Material Data Compilation for Superconductor Simulation', 'event_date': {'raw': '2007'}, 'annote': 'EFDA CSU, Garching, 04/18/07'}</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/references/#matproplib.library.references.SIMON_1992","title":"<code>SIMON_1992 = {'id': 'simon1992', 'type': 'report', 'author': [{'family': 'Simon, J., Drexler, E. S., and Reed, R. P.'}], 'title': 'NIST Monograph 177, Properties of Copper and Copper Alloys at Cryogenic Temperatures', 'event_date': {'raw': '1992'}, 'annote': '', 'url': 'https://nvlpubs.nist.gov/nistpubs/Legacy/MONO/nistmonograph177.pdf', 'doi': '10.6028/NIST.MONO.177'}</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/references/#matproplib.library.references.HUST_1984","title":"<code>HUST_1984 = {'id': 'hust1984', 'type': 'report', 'author': [{'family': 'Hust, J. G., and Lankford, A. B.'}], 'title': 'THERMAL CONDUCTIVITY OF ALUMINUM, COPPER, IRON, AND TUNGSTEN FOR TEMPERATURES FROM 1 K TO THE MELTING POINT', 'event_date': {'raw': '1984'}, 'annote': 'NBSIR 84-3007', 'url': 'https://www.govinfo.gov/content/pkg/GOVPUB-C13-5dca61206b094d8b3a54099ebcff1baa/pdf/GOVPUB-C13-5dca61206b094d8b3a54099ebcff1baa.pdf', 'doi': '10.6028/NBS.IR.84-3007'}</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/references/#matproplib.library.references.CHOONG_1975","title":"<code>CHOONG_1975 = {'id': 'choong1975', 'type': 'report', 'author': [{'family': 'Choong, S. K'}], 'title': 'Thermophysical Properties of Stainless Steels', 'event_date': {'raw': '1975'}, 'annote': '', 'url': 'https://www.osti.gov/servlets/purl/4152287', 'doi': '10.2172/4152287'}</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/references/#matproplib.library.references.PLANSEE_2025","title":"<code>PLANSEE_2025 = {'id': 'plansee_w_2025', 'type': 'report', 'author': [{'organisation': 'Plansee'}], 'url': 'https://www.plansee.com/download/?DOKNR=HPM-070-TD-025&amp;DOKAR=QM1&amp;DOKTL=100'}</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/references/#matproplib.library.references.COOLPROP_7","title":"<code>COOLPROP_7 = {'doi': '10.1021/ie4033999', 'id': 'coolprop_7', 'type': 'article', 'journal': 'Industrial &amp; Engineering Chemistry Research', 'author': [{'family': 'Bell, Ian H. and Wronski, Jorrit and Quoilin, Sylvain and Lemort, Vincent'}], 'title': 'Pure and Pseudo-pure Fluid Thermophysical Property Evaluation and the Open-Source Thermophysical Property Library CoolProp', 'event_date': {'raw': '2014'}, 'url': 'http://pubs.acs.org/doi/abs/10.1021/ie4033999'}</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/steel/","title":"steel","text":"<p>Steel materials</p>"},{"location":"source/reference/matproplib/library/steel/#matproplib.library.steel.SS316_L","title":"<code>SS316_L</code>","text":"<p>               Bases: <code>FullMaterial</code></p> <p>Stainless Steel 316L material. Properties from publicly available Choong 1975 report.</p> Source code in <code>matproplib/library/steel.py</code> <pre><code>@rebuild\nclass SS316_L(FullMaterial):\n    \"\"\"\n    Stainless Steel 316L material. Properties from publicly available Choong 1975 report.\n    \"\"\"\n\n    name: str = Field(default=\"SS316L\")\n    elements: Elements = Field(\n        default={\n            \"Fe\": 0.70345,\n            \"C\": 0.0003,\n            \"Cr\": 0.17,\n            \"Ni\": 0.105,\n            \"Mo\": 0.02125,\n            \"fraction_type\": \"mass\",\n        }\n    )\n    reference: References = CHOONG_1975\n    converters: Converters = Field(\n        default_factory=lambda: OpenMCNeutronicConfig(\n            percent_type=\"atomic\",\n        )\n    )\n    properties: PropertiesT_co = props(\n        as_field=True,\n        density=_ss316l_density,\n        specific_heat_capacity=_ss316l_specific_heat_capacity,\n        coefficient_thermal_expansion=_ss316l_thermal_expansion_coefficient,\n        thermal_conductivity=_ss316l_thermal_conductivity,\n    )\n</code></pre>"},{"location":"source/reference/matproplib/library/steel/#matproplib.library.steel.SS316_L.name","title":"<code>name = Field(default='SS316L')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/library/steel/#matproplib.library.steel.SS316_L.elements","title":"<code>elements = Field(default={'Fe': 0.70345, 'C': 0.0003, 'Cr': 0.17, 'Ni': 0.105, 'Mo': 0.02125, 'fraction_type': 'mass'})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/library/steel/#matproplib.library.steel.SS316_L.reference","title":"<code>reference = CHOONG_1975</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/library/steel/#matproplib.library.steel.SS316_L.converters","title":"<code>converters = Field(default_factory=(lambda: OpenMCNeutronicConfig(percent_type='atomic')))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/library/steel/#matproplib.library.steel.SS316_L.properties","title":"<code>properties = props(as_field=True, density=_ss316l_density, specific_heat_capacity=_ss316l_specific_heat_capacity, coefficient_thermal_expansion=_ss316l_thermal_expansion_coefficient, thermal_conductivity=_ss316l_thermal_conductivity)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/library/superconductors/","title":"superconductors","text":"<p>Superconducting materials</p>"},{"location":"source/reference/matproplib/library/superconductors/#matproplib.library.superconductors.NBS3N_WST_TF_STRAND","title":"<code>NBS3N_WST_TF_STRAND = Nb3SnBotturaParameterisation(constant=83075000000.0, p=0.593, q=2.156, c_a1=50.06, c_a2=0.0, eps_0a=0.00312, eps_m=(-0.00059), b_c20m=33.24, t_c0max=16.34, name='Nb3Sn WST TF Strand', reference=CORATO_2016)</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/superconductors/#matproplib.library.superconductors.NB3SN_EUTF4_STRAND","title":"<code>NB3SN_EUTF4_STRAND = Nb3SnBotturaParameterisation(constant=76189000000.0, p=0.63, q=2.1, c_a1=44.48, c_a2=0.0, eps_0a=0.00256, eps_m=(-0.0011), b_c20m=32.97, t_c0max=16.06, name='Nb3Sn EUTF4 Strand', reference=CORATO_2016)</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/superconductors/#matproplib.library.superconductors.NB3SN_CSJA6_STRAND","title":"<code>NB3SN_CSJA6_STRAND = Nb3SnBotturaParameterisation(constant=79560000000.0, p=0.556, q=1.698, c_a1=45.74, c_a2=4.431, eps_0a=0.00232, eps_m=(-0.00061), b_c20m=29.39, t_c0max=16.48, name='Nb3Sn CSJA6 Strand', reference=CORATO_2016)</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/superconductors/#matproplib.library.superconductors.NBTI_ITER_STRAND","title":"<code>NBTI_ITER_STRAND = NbTiBotturaParameterisation(constant=168512000000.0, alpha=1.0, beta=1.54, gamma=2.1, b_c20=14.61, t_c0=9.03, name='NbTi ITER Strand', reference=CORATO_2016)</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/superconductors/#matproplib.library.superconductors.NB3SN_CERN_STRAND","title":"<code>NB3SN_CERN_STRAND = SummersParameterisation(constant=43100000000.0, alpha=900.0, t_c0m=18.0, b_c20m=27.6, name='Nb3Sn CERN Strand', reference=FERRACIN_2022)</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/superconductors/#matproplib.library.superconductors.NbTi","title":"<code>NbTi = material('NbTi', elements='NbTi', properties=(props(as_field=True, density=6000.0, poissons_ratio=0.33, specific_heat_capacity=nbti_specific_heat_capacity, superconducting_parameterisation=NBTI_ITER_STRAND)), converters=(OpenMCNeutronicConfig()))</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/superconductors/#matproplib.library.superconductors.Nb3Sn","title":"<code>Nb3Sn = material('Nb3Sn', elements='Nb3Sn', properties=(props(as_field=True, density=8040.0, poissons_ratio=0.33, specific_heat_capacity=nb3sn_specific_heat_capacity, superconducting_parameterisation=NBS3N_WST_TF_STRAND)), converters=(OpenMCNeutronicConfig()))</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/library/superconductors/#matproplib.library.superconductors.nbti_specific_heat_capacity","title":"<code>nbti_specific_heat_capacity(op_cond)</code>","text":"<p>Calculates the specific heat capacity of NbTi as a function of temperature. Provides the temperature-dependent specific heat capacity [J/(kg\u00b7K)] of the A15 superconductor NbTi.</p> Notes <p>The superconducting part is ignored, which is typical in thermal quench calculations.</p> <ul> <li>EFDA Material Data Compilation for Superconductor Simulation, P. Bauer,   H. Rajainmaki, E. Salpietro, EFDA CSU, Garching, 04/18/07.</li> <li>Elrod S.A. Miller J.R., Dresner L.,  \u201cThe specific heat of NbTi from 0-7T between 4.2 and 20K\u201d, Advances in Cryogenic Engineering Materials,   Vol. 28, 1981   .. doi:: 10.1007/978-1-4613-3542-9_60</li> </ul> Source code in <code>matproplib/library/superconductors.py</code> <pre><code>@dependentphysicalproperty(\n    SpecificHeatCapacity,\n    op_cond_config={\"temperature\": (\"degK\", 4, 300)},\n    reference={\n        \"id\": \"nb3sn_cp\",\n        \"type\": \"report\",\n        \"title\": (\n            \"EFDA Material Data Compilation for Superconductor Simulation, \"\n            \"P. Bauer, H. Rajainmaki, E. Salpietro, EFDA CSU, Garching, 04/18/07\"\n        ),\n    },\n)\ndef nbti_specific_heat_capacity(op_cond: OpCondT) -&gt; float:\n    \"\"\"\n    Calculates the specific heat capacity of NbTi as a function of temperature.\n    Provides the temperature-dependent specific heat capacity [J/(kg\u00b7K)] of the A15\n    superconductor NbTi.\n\n    Notes\n    -----\n    The superconducting part is ignored, which is typical in thermal quench calculations.\n\n    - EFDA Material Data Compilation for Superconductor Simulation, P. Bauer,\n      H. Rajainmaki, E. Salpietro, EFDA CSU, Garching, 04/18/07.\n    - Elrod S.A. Miller J.R., Dresner L.,\n     \u201cThe specific heat of NbTi from 0-7T between 4.2 and 20K\u201d, Advances in Cryogenic Engineering Materials,\n      Vol. 28, 1981\n      .. doi:: 10.1007/978-1-4613-3542-9_60\n    \"\"\"  # noqa: DOC201, E501\n    gamma: Final[float] = 0.145  # [J/K\u00b2/kg] (Grueneisen)\n    beta: Final[float] = 0.0023  # [J/K\u2074/kg] (Debye)\n    cp_300: Final[float] = 400.0  # [J/K/kg] Room-temperature specific heat\n\n    # Normally conducting specific heat capacity (i.e. ignoring transition from\n    # superconducting state)\n    cp_low = beta * op_cond.temperature**3 + gamma * op_cond.temperature\n    return 1.0 / (1.0 / cp_300 + 1.0 / cp_low)\n</code></pre>"},{"location":"source/reference/matproplib/library/superconductors/#matproplib.library.superconductors.nb3sn_specific_heat_capacity","title":"<code>nb3sn_specific_heat_capacity(op_cond)</code>","text":"<p>Calculates the specific heat capacity of Nb\u2083Sn as a function of temperature. Provides the temperature-dependent specific heat capacity [J/(kg\u00b7K)] of the A15 superconductor Nb\u2083Sn.</p> Notes <p>The superconducting part is ignored, which is typical in thermal quench calculations.</p> <ul> <li>EFDA Material Data Compilation for Superconductor Simulation,   P. Bauer, H. Rajainmaki, E. Salpietro, EFDA CSU, Garching, 04/18/07.</li> <li>ITER DRG1 Annex, Superconducting Material Database,   Article 5, N 11 FDR 42 01-07-05 R 0.1.</li> <li>V.D. Arp, Stability and Thermal Quenches in Force-Cooled Superconducting Cables,   Superconducting MHD Magnet Design Conf., MIT, pp 142-157, 1980.</li> <li>G.S. Knapp, S.D. Bader, Z. Fisk,   Phonon properties of A-15 superconductors obtained from heat capacity measurements,   Phys. Rev. B, 13(9), pp 3783-3789, 1976.   .. doi:: 10.1103/PhysRevB.13.3783</li> </ul> Source code in <code>matproplib/library/superconductors.py</code> <pre><code>@dependentphysicalproperty(\n    SpecificHeatCapacity,\n    op_cond_config={\"temperature\": (\"degK\", 2, 300)},\n    reference={\n        \"id\": \"nb3sn_cp\",\n        \"type\": \"report\",\n        \"title\": (\n            \"EFDA Material Data Compilation for Superconductor Simulation, P. Bauer,\"\n            \" H. Rajainmaki, E. Salpietro, EFDA CSU, Garching, 04/18/07\"\n        ),\n    },\n)\ndef nb3sn_specific_heat_capacity(op_cond: OpCondT) -&gt; float:\n    \"\"\"\n    Calculates the specific heat capacity of Nb\u2083Sn as a function of temperature.\n    Provides the temperature-dependent specific heat capacity [J/(kg\u00b7K)] of the A15\n    superconductor Nb\u2083Sn.\n\n    Notes\n    -----\n    The superconducting part is ignored, which is typical in thermal quench calculations.\n\n\n    - EFDA Material Data Compilation for Superconductor Simulation,\n      P. Bauer, H. Rajainmaki, E. Salpietro, EFDA CSU, Garching, 04/18/07.\n    - ITER DRG1 Annex, Superconducting Material Database,\n      Article 5, N 11 FDR 42 01-07-05 R 0.1.\n    - V.D. Arp, Stability and Thermal Quenches in Force-Cooled Superconducting Cables,\n      Superconducting MHD Magnet Design Conf., MIT, pp 142-157, 1980.\n    - G.S. Knapp, S.D. Bader, Z. Fisk,\n      Phonon properties of A-15 superconductors obtained from heat capacity measurements,\n      Phys. Rev. B, 13(9), pp 3783-3789, 1976.\n      .. doi:: 10.1103/PhysRevB.13.3783\n    \"\"\"  # noqa: DOC201\n    gamma: Final[float] = 0.1  # [J/K\u00b2/kg] (Grueneisen)\n    beta: Final[float] = 0.001  # [J/K\u2074/kg] (Debye)\n    cp_300: Final[float] = 210.0  # [J/K/kg] Room-temperature specific heat\n\n    # Normally conducting specific heat capacity (i.e. ignoring transition from\n    # superconducting state)\n    cp_low = beta * op_cond.temperature**3 + gamma * op_cond.temperature\n    return 1.0 / (1.0 / cp_300 + 1.0 / cp_low)\n</code></pre>"},{"location":"source/reference/matproplib/library/tungsten/","title":"tungsten","text":"<p>Tungsten materials</p>"},{"location":"source/reference/matproplib/library/tungsten/#matproplib.library.tungsten.PlanseeTungsten","title":"<code>PlanseeTungsten</code>","text":"<p>               Bases: <code>FullMaterial</code></p> <p>Plansee ultra-high purity Tungsten, stress-relieved sheet. Properties from publicly available Plansee data.</p> Source code in <code>matproplib/library/tungsten.py</code> <pre><code>@rebuild\nclass PlanseeTungsten(FullMaterial):\n    \"\"\"\n    Plansee ultra-high purity Tungsten, stress-relieved sheet.\n    Properties from publicly available Plansee data.\n    \"\"\"\n\n    name: str = Field(\n        default=\"Plansee ultra-high purity Tungsten (W-UHP), stress-relieved sheet\"\n    )\n    elements: Elements = Field(\n        default={\n            \"W\": 0.999966,\n            \"Al\": 1e-6,\n            \"Cr\": 3e-6,\n            \"Cu\": 1e-6,\n            \"Fe\": 8e-6,\n            \"K\": 1e-6,\n            \"Mo\": 12e-6,\n            \"Ni\": 2e-6,\n            \"Si\": 1e-6,\n            \"N\": 1e-6,\n            \"O\": 2e-6,\n            \"Cd\": 1e-6,\n            \"Pb\": 1e-6,\n            \"fraction_type\": \"mass\",\n        }\n    )\n    converters: Converters = Field(\n        default_factory=lambda: OpenMCNeutronicConfig(\n            percent_type=\"atomic\",\n        )\n    )\n    reference: References = PLANSEE_2025\n    properties: PropertiesT_co = props(\n        as_field=True,\n        density=19250.0,\n        poissons_ratio=0.28,\n        youngs_modulus=_w_youngs_modulus,\n        coefficient_thermal_expansion=_w_coefficient_thermal_expansion,\n        thermal_conductivity=_w_thermal_conductivity,\n        specific_heat_capacity=_w_specific_heat_capacity,\n        electrical_resistivity=_w_electrical_resistivity,\n    )\n</code></pre>"},{"location":"source/reference/matproplib/library/tungsten/#matproplib.library.tungsten.PlanseeTungsten.name","title":"<code>name = Field(default='Plansee ultra-high purity Tungsten (W-UHP), stress-relieved sheet')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/library/tungsten/#matproplib.library.tungsten.PlanseeTungsten.elements","title":"<code>elements = Field(default={'W': 0.999966, 'Al': 1e-06, 'Cr': 3e-06, 'Cu': 1e-06, 'Fe': 8e-06, 'K': 1e-06, 'Mo': 1.2e-05, 'Ni': 2e-06, 'Si': 1e-06, 'N': 1e-06, 'O': 2e-06, 'Cd': 1e-06, 'Pb': 1e-06, 'fraction_type': 'mass'})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/library/tungsten/#matproplib.library.tungsten.PlanseeTungsten.converters","title":"<code>converters = Field(default_factory=(lambda: OpenMCNeutronicConfig(percent_type='atomic')))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/library/tungsten/#matproplib.library.tungsten.PlanseeTungsten.reference","title":"<code>reference = PLANSEE_2025</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/library/tungsten/#matproplib.library.tungsten.PlanseeTungsten.properties","title":"<code>properties = props(as_field=True, density=19250.0, poissons_ratio=0.28, youngs_modulus=_w_youngs_modulus, coefficient_thermal_expansion=_w_coefficient_thermal_expansion, thermal_conductivity=_w_thermal_conductivity, specific_heat_capacity=_w_specific_heat_capacity, electrical_resistivity=_w_electrical_resistivity)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/dependent/","title":"dependent","text":"<p>Dependent properties of matproplib</p>"},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.DependentCallable","title":"<code>DependentCallable</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>DependentPhysicalProperty callable typing</p> Source code in <code>matproplib/properties/dependent.py</code> <pre><code>class DependentCallable(Protocol):\n    \"\"\"DependentPhysicalProperty callable typing\"\"\"\n\n    def __call__(  # noqa: D102\n        self,\n        op_cond: OpCondT,\n        *args,\n        **kwargs,\n    ) -&gt; float: ...\n</code></pre>"},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.DependentPhysicalPropertyTD","title":"<code>DependentPhysicalPropertyTD</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>DependentPhysicalProperty typing</p> Source code in <code>matproplib/properties/dependent.py</code> <pre><code>class DependentPhysicalPropertyTD(TypedDict):\n    \"\"\"DependentPhysicalProperty typing\"\"\"\n\n    value: Callable[[OpCondT], ArrayFloat] | ArrayFloat\n    unit: NotRequired[Unit | str]\n    op_cond_config: NotRequired[\n        DependentPropertyConditionConfig\n        | dict[str, tuple[str, float, float] | tuple[str, float] | tuple[float, float]]\n        | None\n    ]\n    reference: NotRequired[References | None]\n</code></pre>"},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.DependentPhysicalPropertyTD.value","title":"<code>value</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.DependentPhysicalPropertyTD.unit","title":"<code>unit</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.DependentPhysicalPropertyTD.op_cond_config","title":"<code>op_cond_config</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.DependentPhysicalPropertyTD.reference","title":"<code>reference</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.DependentPhysicalProperty","title":"<code>DependentPhysicalProperty</code>","text":"<p>               Bases: <code>BasePhysicalProperty</code></p> <p>A property that is dependent on operating conditions</p> Source code in <code>matproplib/properties/dependent.py</code> <pre><code>class DependentPhysicalProperty(BasePhysicalProperty):\n    \"\"\"A property that is dependent on operating conditions\"\"\"\n\n    value: Callable[[OpCondT], ArrayFloat]\n    op_cond_config: DependentPropertyConditionConfig | None = None\n\n    @classmethod\n    def __pydantic_init_subclass__(cls, **kwargs):  # noqa: PLW3201\n        \"\"\"Ensure default units are set for a property\n\n        Raises\n        ------\n        ValueError\n            Default unit not set on class\n        \"\"\"\n        super().__pydantic_init_subclass__(**kwargs)\n        if isinstance(cls.model_fields[\"unit\"].default, PydanticUndefinedType):\n            raise ValueError(  # noqa: TRY004\n                f\"No default unit set on {cls}.\"\n                \" Please set a default unit attribute 'unit: Unit | str = \\\"myunit\\\"'\"\n            )\n\n    @field_serializer(\"value\")\n    @classmethod\n    def _serialise_value(\n        cls, value: Callable[[OpCondT], ArrayFloat] | None\n    ) -&gt; ArrayFloat | bool | dict[str, float | bool] | None:\n        \"\"\"\n        Returns\n        -------\n        :\n            Serialised value\n        \"\"\"\n        if isinstance(value, partial):\n            value = value.func\n\n        if isinstance(value, _NoDependence):\n            return value(None)\n\n        if isinstance(value, _WrapCallable):\n            return {\n                \"conv_unit\": value.unit_val.units,\n                \"func\": cls._serialise_value(value.value),\n            }\n\n        if is_lambda(value):\n            lam = inspect_lambda(value)\n            return lam.text\n\n        if inspect.isfunction(value):\n            log.debug(\"function\")\n            return stringify_function(value)\n\n        if value is None:\n            return None\n\n        raise NotImplementedError\n\n    @model_validator(mode=\"before\")\n    def _from_static_value(self):\n        \"\"\"Static value validation\"\"\"  # noqa: DOC201\n        if isinstance(self, _Wrapped):\n            model = getattr(self, f\"_{type(self).__name__}__model\")\n            return {\n                \"value\": model.value,\n                \"unit\": model.unit,\n                \"op_cond_config\": model.op_cond_config,\n            }\n\n        if not isinstance(self, DependentPhysicalProperty):\n            if not isinstance(self, dict):\n                # Single number or a function not wrapped in a dictionary\n                if isinstance(self, tuple):\n                    v = self[0]\n                    u = self[1]\n                else:\n                    v = self\n                    u = None\n\n                return {\n                    \"value\": _no_dependence(v)\n                    if isinstance(v, float | int | complex)\n                    else v,\n                    **({} if u is None else {\"unit\": u}),\n                }\n            if self.get(\"value\", None) is not None and not callable(self[\"value\"]):\n                val = self[\"value\"]\n                # function or single number\n                self[\"value\"] = (\n                    deserialise(val)\n                    if isinstance(val, str) and (\"def\" in val or \"lambda\" in val)\n                    else _no_dependence(val)\n                )\n        return self\n\n    @model_validator(mode=\"after\")\n    def _unitify(self):\n        \"\"\"Convert value and unit to default\n\n        Raises\n        ------\n        ValueError\n            Failed unit conversion\n\n        Returns\n        -------\n        :\n            The property instance\n        \"\"\"\n        unit_val, default = super()._unitify()\n\n        if unit_val.units != default or not np.isclose(unit_val.magnitude, 1):\n            log.debug(\"Non default unit used, wrapping value\")\n            if isinstance(self.value, _NoDependence):\n                wrap_callable = _no_dependence(\n                    unit_conversion(unit_val * self.value(None), default)\n                )\n            else:\n                wrap_callable = _WrapCallable(self.value, unit_val, default)\n            object.__setattr__(self, \"value\", wrap_callable)  # noqa: PLC2801\n        object.__setattr__(self, \"unit\", default)  # noqa: PLC2801\n        return self\n\n    def value_as(self, op_cond: OpCondT, unit: str | Unit, *args, **kwargs) -&gt; float:\n        \"\"\"\n        Returns\n        -------\n        :\n            value in another unit\n\n        Raises\n        ------\n        ValueError\n            Failed unit conversion\n        \"\"\"\n        if self.op_cond_config is not None:\n            op_cond = _modify_and_check(op_cond, self.op_cond_config)\n\n        try:\n            return (\n                ureg.Quantity(\n                    self.value(op_cond, *args, **kwargs),\n                    self.unit,\n                )\n                .to(unit)\n                .magnitude\n            )\n        except DimensionalityError as de:\n            raise ValueError(\n                f\"Cannot convert from '{de.args[0]}' \"\n                f\"({de.args[2]}) to '{de.args[1]}' ({de.args[3]})\"\n            ) from None\n\n    def __call__(self, op_cond: OpCondT, *args, **kwargs) -&gt; float:\n        \"\"\"Helper to inject and modify conditions as required\n\n        Returns\n        -------\n        :\n            Property value at conditons\n        \"\"\"\n        if self.op_cond_config is not None:\n            op_cond = _modify_and_check(\n                OperationalConditions.model_validate(op_cond), self.op_cond_config\n            )\n        return self.value(op_cond, *args, **kwargs)\n\n    def __str__(self) -&gt; str:  # noqa: D105\n        return (\n            f\"{type(self).__name__}(value={self.value}, \"\n            f\"unit={self.unit:~P}, \"\n            f\"op_cond_config={self.op_cond_config}, \"\n            f\"reference={self.reference.__str__()})\"\n        )\n</code></pre>"},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.DependentPhysicalProperty.value","title":"<code>value</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.DependentPhysicalProperty.op_cond_config","title":"<code>op_cond_config = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.DependentPhysicalProperty.value_as","title":"<code>value_as(op_cond, unit, *args, **kwargs)</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>value in another unit</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Failed unit conversion</p> Source code in <code>matproplib/properties/dependent.py</code> <pre><code>def value_as(self, op_cond: OpCondT, unit: str | Unit, *args, **kwargs) -&gt; float:\n    \"\"\"\n    Returns\n    -------\n    :\n        value in another unit\n\n    Raises\n    ------\n    ValueError\n        Failed unit conversion\n    \"\"\"\n    if self.op_cond_config is not None:\n        op_cond = _modify_and_check(op_cond, self.op_cond_config)\n\n    try:\n        return (\n            ureg.Quantity(\n                self.value(op_cond, *args, **kwargs),\n                self.unit,\n            )\n            .to(unit)\n            .magnitude\n        )\n    except DimensionalityError as de:\n        raise ValueError(\n            f\"Cannot convert from '{de.args[0]}' \"\n            f\"({de.args[2]}) to '{de.args[1]}' ({de.args[3]})\"\n        ) from None\n</code></pre>"},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.UndefinedProperty","title":"<code>UndefinedProperty</code>","text":"<p>               Bases: <code>DependentPhysicalProperty</code></p> <p>Undefined property</p> Source code in <code>matproplib/properties/dependent.py</code> <pre><code>class UndefinedProperty(DependentPhysicalProperty):\n    \"\"\"Undefined property\"\"\"\n\n    value: None = Field(default=None, frozen=True)\n    unit: Literal[\"\"] = Field(default=\"\", frozen=True)\n\n    def __call__(self, op_cond: OpCondT, *args, **kwargs):\n        \"\"\"Call for Undefined property is undefined\"\"\"\n        raise NotImplementedError(\"\")\n\n    value_as = __call__\n</code></pre>"},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.UndefinedProperty.value","title":"<code>value = Field(default=None, frozen=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.UndefinedProperty.unit","title":"<code>unit = Field(default='', frozen=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.UndefinedProperty.value_as","title":"<code>value_as = __call__</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.AttributeErrorProperty","title":"<code>AttributeErrorProperty</code>","text":"<p>               Bases: <code>UndefinedProperty</code></p> <p>Raise AttributeError on access</p> Source code in <code>matproplib/properties/dependent.py</code> <pre><code>class AttributeErrorProperty(UndefinedProperty):\n    \"\"\"Raise AttributeError on access\"\"\"\n\n    msg: str = Field(default=\"\", frozen=True)\n\n    def __call__(self, op_cond: OpCondT, *args, **kwargs):  # noqa: ARG002\n        \"\"\"Call for Undefined property is undefined\"\"\"  # noqa: DOC501\n        raise AttributeError(self.msg)\n\n    value_as = __call__\n</code></pre>"},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.AttributeErrorProperty.msg","title":"<code>msg = Field(default='', frozen=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.AttributeErrorProperty.value_as","title":"<code>value_as = __call__</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.Density","title":"<code>Density</code>","text":"<p>               Bases: <code>DependentPhysicalProperty</code></p> <p>Density of a material</p> Source code in <code>matproplib/properties/dependent.py</code> <pre><code>class Density(DependentPhysicalProperty):\n    \"\"\"Density of a material\"\"\"\n\n    unit: Unit | str = \"kg/m^3\"\n\n    @classmethod\n    def from_nuclear_units(\n        cls,\n        elements: dict[str, float],\n        value: float,\n        unit: str = \"atom/cm^3\",\n    ) -&gt; Density:\n        \"\"\"Set density from nuclear units\n\n        Returns\n        -------\n        :\n            Initialised density object\n        \"\"\"\n        tval = 0\n\n        if \"atom\" in unit:\n            for e_n, e_f in elements.items():\n                e = getattr(pt, e_n)\n                tval += (\n                    ureg.Quantity(e.mass * e_f * value, e.mass_units).to(\"amu\").magnitude\n                )\n\n        if \"b-cm\" in unit:\n            unit = unit.replace(\"b-cm\", \"(b.cm)\")\n\n        return cls(value=tval, unit=unit.replace(\"atom\", \"amu\"))\n\n    @classmethod\n    def from_unit_cell(cls):\n        \"\"\"Create the density object using values from the OpenMC converter\n\n        Notes\n        -----\n        The OpenMC converter must be available on the material\n        \"\"\"  # noqa: DOC201\n\n        def _density(self, _oc):\n            omc_conv = self.converters[\"openmc\"]\n            return density_from_unit_cell(\n                self.elements._no_atoms or omc_conv.number_of_atoms_in_sample,  # noqa: SLF001\n                omc_conv.atoms_per_unit_cell,\n                self.elements.average_molar_mass,\n                omc_conv.volume_of_unit_cell,\n            )\n\n        return cls(value=_density)\n</code></pre>"},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.Density.unit","title":"<code>unit = 'kg/m^3'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.Density.from_nuclear_units","title":"<code>from_nuclear_units(elements, value, unit='atom/cm^3')</code>  <code>classmethod</code>","text":"<p>Set density from nuclear units</p> <p>Returns:</p> Type Description <code>Density</code> <p>Initialised density object</p> Source code in <code>matproplib/properties/dependent.py</code> <pre><code>@classmethod\ndef from_nuclear_units(\n    cls,\n    elements: dict[str, float],\n    value: float,\n    unit: str = \"atom/cm^3\",\n) -&gt; Density:\n    \"\"\"Set density from nuclear units\n\n    Returns\n    -------\n    :\n        Initialised density object\n    \"\"\"\n    tval = 0\n\n    if \"atom\" in unit:\n        for e_n, e_f in elements.items():\n            e = getattr(pt, e_n)\n            tval += (\n                ureg.Quantity(e.mass * e_f * value, e.mass_units).to(\"amu\").magnitude\n            )\n\n    if \"b-cm\" in unit:\n        unit = unit.replace(\"b-cm\", \"(b.cm)\")\n\n    return cls(value=tval, unit=unit.replace(\"atom\", \"amu\"))\n</code></pre>"},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.Density.from_unit_cell","title":"<code>from_unit_cell()</code>  <code>classmethod</code>","text":"<p>Create the density object using values from the OpenMC converter</p> Notes <p>The OpenMC converter must be available on the material</p> Source code in <code>matproplib/properties/dependent.py</code> <pre><code>@classmethod\ndef from_unit_cell(cls):\n    \"\"\"Create the density object using values from the OpenMC converter\n\n    Notes\n    -----\n    The OpenMC converter must be available on the material\n    \"\"\"  # noqa: DOC201\n\n    def _density(self, _oc):\n        omc_conv = self.converters[\"openmc\"]\n        return density_from_unit_cell(\n            self.elements._no_atoms or omc_conv.number_of_atoms_in_sample,  # noqa: SLF001\n            omc_conv.atoms_per_unit_cell,\n            self.elements.average_molar_mass,\n            omc_conv.volume_of_unit_cell,\n        )\n\n    return cls(value=_density)\n</code></pre>"},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.CoerciveField","title":"<code>CoerciveField</code>","text":"<p>               Bases: <code>DependentPhysicalProperty</code></p> <p>Coercive Field</p> Source code in <code>matproplib/properties/dependent.py</code> <pre><code>class CoerciveField(DependentPhysicalProperty):\n    \"\"\"Coercive Field\"\"\"\n\n    unit: Unit | str = \"A/m\"\n</code></pre>"},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.CoerciveField.unit","title":"<code>unit = 'A/m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.ThermalConductivity","title":"<code>ThermalConductivity</code>","text":"<p>               Bases: <code>DependentPhysicalProperty</code></p> <p>Thermal conductivity</p> Source code in <code>matproplib/properties/dependent.py</code> <pre><code>class ThermalConductivity(DependentPhysicalProperty):\n    \"\"\"Thermal conductivity\"\"\"\n\n    unit: Unit | str = \"W/(m.K)\"\n</code></pre>"},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.ThermalConductivity.unit","title":"<code>unit = 'W/(m.K)'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.MagneticSaturation","title":"<code>MagneticSaturation</code>","text":"<p>               Bases: <code>DependentPhysicalProperty</code></p> <p>Magnetic Saturation</p> Source code in <code>matproplib/properties/dependent.py</code> <pre><code>class MagneticSaturation(DependentPhysicalProperty):\n    \"\"\"Magnetic Saturation\"\"\"\n\n    unit: Unit | str = \"A.m^2/kg\"\n</code></pre>"},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.MagneticSaturation.unit","title":"<code>unit = 'A.m^2/kg'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.ViscousRemanentMagnetism","title":"<code>ViscousRemanentMagnetism</code>","text":"<p>               Bases: <code>DependentPhysicalProperty</code></p> <p>Viscous remanent magnetism</p> Source code in <code>matproplib/properties/dependent.py</code> <pre><code>class ViscousRemanentMagnetism(DependentPhysicalProperty):\n    \"\"\"Viscous remanent magnetism\"\"\"\n\n    unit: Unit | str = \"A.m^2/kg\"\n</code></pre>"},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.ViscousRemanentMagnetism.unit","title":"<code>unit = 'A.m^2/kg'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.SpecificHeatCapacity","title":"<code>SpecificHeatCapacity</code>","text":"<p>               Bases: <code>DependentPhysicalProperty</code></p> <p>Specific Heat Capacity</p> Source code in <code>matproplib/properties/dependent.py</code> <pre><code>class SpecificHeatCapacity(DependentPhysicalProperty):\n    \"\"\"Specific Heat Capacity\"\"\"\n\n    unit: Unit | str = \"J/kg/K\"\n</code></pre>"},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.SpecificHeatCapacity.unit","title":"<code>unit = 'J/kg/K'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.CoefficientThermalExpansion","title":"<code>CoefficientThermalExpansion</code>","text":"<p>               Bases: <code>DependentPhysicalProperty</code></p> <p>Coefficient of thermal expansion (CTE)</p> Source code in <code>matproplib/properties/dependent.py</code> <pre><code>class CoefficientThermalExpansion(DependentPhysicalProperty):\n    \"\"\"Coefficient of thermal expansion (CTE)\"\"\"\n\n    unit: Unit | str = \"K^-1\"\n</code></pre>"},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.CoefficientThermalExpansion.unit","title":"<code>unit = 'K^-1'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.ElectricalResistivity","title":"<code>ElectricalResistivity</code>","text":"<p>               Bases: <code>DependentPhysicalProperty</code></p> <p>Electrical resistivity</p> Source code in <code>matproplib/properties/dependent.py</code> <pre><code>class ElectricalResistivity(DependentPhysicalProperty):\n    \"\"\"Electrical resistivity\"\"\"\n\n    unit: Unit | str = \"ohm.m\"\n</code></pre>"},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.ElectricalResistivity.unit","title":"<code>unit = 'ohm.m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.Stress","title":"<code>Stress</code>","text":"<p>               Bases: <code>DependentPhysicalProperty</code></p> <p>Stress</p> Source code in <code>matproplib/properties/dependent.py</code> <pre><code>class Stress(DependentPhysicalProperty):\n    \"\"\"Stress\"\"\"\n\n    unit: Unit | str = \"Pa\"\n</code></pre>"},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.Stress.unit","title":"<code>unit = 'Pa'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.YieldStress","title":"<code>YieldStress</code>","text":"<p>               Bases: <code>Stress</code></p> <p>Yield Stress</p> Source code in <code>matproplib/properties/dependent.py</code> <pre><code>class YieldStress(Stress):\n    \"\"\"Yield Stress\"\"\"\n</code></pre>"},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.TensileStress","title":"<code>TensileStress</code>","text":"<p>               Bases: <code>Stress</code></p> <p>Tensile Stress</p> Source code in <code>matproplib/properties/dependent.py</code> <pre><code>class TensileStress(Stress):\n    \"\"\"Tensile Stress\"\"\"\n</code></pre>"},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.Stiffness","title":"<code>Stiffness</code>","text":"<p>               Bases: <code>DependentPhysicalProperty</code></p> <p>Stiffness Property</p> Source code in <code>matproplib/properties/dependent.py</code> <pre><code>class Stiffness(DependentPhysicalProperty):\n    \"\"\"Stiffness Property\"\"\"\n\n    unit: Unit | str = \"Pa\"\n</code></pre>"},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.Stiffness.unit","title":"<code>unit = 'Pa'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.YoungsModulus","title":"<code>YoungsModulus</code>","text":"<p>               Bases: <code>Stiffness</code></p> <p>Youngs Modulus</p> Source code in <code>matproplib/properties/dependent.py</code> <pre><code>class YoungsModulus(Stiffness):\n    \"\"\"Youngs Modulus\"\"\"\n</code></pre>"},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.ShearModulus","title":"<code>ShearModulus</code>","text":"<p>               Bases: <code>Stiffness</code></p> <p>Shear Modulus</p> Source code in <code>matproplib/properties/dependent.py</code> <pre><code>class ShearModulus(Stiffness):\n    \"\"\"Shear Modulus\"\"\"\n</code></pre>"},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.BulkModulus","title":"<code>BulkModulus</code>","text":"<p>               Bases: <code>Stiffness</code></p> <p>Bulk Modulus</p> Source code in <code>matproplib/properties/dependent.py</code> <pre><code>class BulkModulus(Stiffness):\n    \"\"\"Bulk Modulus\"\"\"\n</code></pre>"},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.Ratio","title":"<code>Ratio</code>","text":"<p>               Bases: <code>DependentPhysicalProperty</code></p> <p>A ratio property</p> Source code in <code>matproplib/properties/dependent.py</code> <pre><code>class Ratio(DependentPhysicalProperty):\n    \"\"\"A ratio property\"\"\"\n\n    unit: Unit | Literal[\"\"] = \"\"\n</code></pre>"},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.Ratio.unit","title":"<code>unit = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.PoissonsRatio","title":"<code>PoissonsRatio</code>","text":"<p>               Bases: <code>Ratio</code></p> <p>Poisson's ratio</p> Source code in <code>matproplib/properties/dependent.py</code> <pre><code>class PoissonsRatio(Ratio):\n    \"\"\"Poisson's ratio\"\"\"\n</code></pre>"},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.ResidualResistanceRatio","title":"<code>ResidualResistanceRatio</code>","text":"<p>               Bases: <code>Ratio</code></p> <p>Residual Resistance Ratio</p> Source code in <code>matproplib/properties/dependent.py</code> <pre><code>class ResidualResistanceRatio(Ratio):\n    \"\"\"Residual Resistance Ratio\"\"\"\n</code></pre>"},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.Unitless","title":"<code>Unitless</code>","text":"<p>               Bases: <code>DependentPhysicalProperty</code></p> <p>A unitless property</p> Source code in <code>matproplib/properties/dependent.py</code> <pre><code>class Unitless(DependentPhysicalProperty):\n    \"\"\"A unitless property\"\"\"\n\n    unit: Unit | Literal[\"\"] = \"\"\n</code></pre>"},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.Unitless.unit","title":"<code>unit = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/dependent/#matproplib.properties.dependent.MagneticSusceptibility","title":"<code>MagneticSusceptibility</code>","text":"<p>               Bases: <code>Unitless</code></p> <p>Magnetic Susceptibility</p> Source code in <code>matproplib/properties/dependent.py</code> <pre><code>class MagneticSusceptibility(Unitless):\n    \"\"\"Magnetic Susceptibility\"\"\"\n</code></pre>"},{"location":"source/reference/matproplib/properties/group/","title":"group","text":"<p>Dependent properties of matproplib</p>"},{"location":"source/reference/matproplib/properties/group/#matproplib.properties.group.Ldefine","title":"<code>Ldefine = UndefinedProperty | DependentPhysicalPropertyTD | ArrayFloat</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/group/#matproplib.properties.group.Properties","title":"<code>Properties</code>","text":"<p>               Bases: <code>BaseGroup</code></p> <p>Base property model</p> Source code in <code>matproplib/properties/group.py</code> <pre><code>class Properties(BaseGroup):\n    \"\"\"Base property model\"\"\"\n\n    model_config = ConfigDict(validate_default=True)\n\n    def __repr__(self) -&gt; str:  # noqa: D105\n        undefined = self.list(include_undefined=None)\n        undefined = f\", undefined_properties={undefined}\" if undefined else \"\"\n        return f\"{type(self).__name__}(defined_properties={self.list()}{undefined})\"\n\n    def __getitem__(self, value):  # noqa: D105\n        # Required until https://github.com/pydantic/pydantic/issues/10851\n        return getattr(self, value)\n\n    __str__ = __repr__\n</code></pre>"},{"location":"source/reference/matproplib/properties/group/#matproplib.properties.group.Properties.model_config","title":"<code>model_config = ConfigDict(validate_default=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/group/#matproplib.properties.group.DefaultProperties","title":"<code>DefaultProperties</code>","text":"<p>               Bases: <code>Properties</code>, <code>Generic[SuperconductingParameterisationT_co]</code></p> <p>Default properties model</p> Source code in <code>matproplib/properties/group.py</code> <pre><code>class DefaultProperties(Properties, Generic[SuperconductingParameterisationT_co]):\n    \"\"\"Default properties model\"\"\"\n\n    density: UndefinedProperty | Density = UndefinedProperty()\n    poissons_ratio: UndefinedProperty | PoissonsRatio = UndefinedProperty()\n    residual_resistance_ratio: UndefinedProperty | ResidualResistanceRatio = (\n        UndefinedProperty()\n    )\n    thermal_conductivity: UndefinedProperty | ThermalConductivity = UndefinedProperty()\n    youngs_modulus: UndefinedProperty | YoungsModulus = UndefinedProperty()\n    shear_modulus: UndefinedProperty | ShearModulus = UndefinedProperty()\n    bulk_modulus: UndefinedProperty | BulkModulus = UndefinedProperty()\n    coefficient_thermal_expansion: UndefinedProperty | CoefficientThermalExpansion = (\n        UndefinedProperty()\n    )\n    specific_heat_capacity: UndefinedProperty | SpecificHeatCapacity = (\n        UndefinedProperty()\n    )\n    electrical_resistivity: UndefinedProperty | ElectricalResistivity = (\n        UndefinedProperty()\n    )\n    magnetic_saturation: UndefinedProperty | MagneticSaturation = UndefinedProperty()\n    magnetic_susceptibility: UndefinedProperty | MagneticSusceptibility = (\n        UndefinedProperty()\n    )\n    viscous_remanent_magnetisation: UndefinedProperty | ViscousRemanentMagnetism = (\n        UndefinedProperty()\n    )\n    coercive_field: UndefinedProperty | CoerciveField = UndefinedProperty()\n    minimum_yield_stress: UndefinedProperty | YieldStress = UndefinedProperty()\n    average_yield_stress: UndefinedProperty | YieldStress = UndefinedProperty()\n    minimum_ultimate_tensile_stress: UndefinedProperty | TensileStress = (\n        UndefinedProperty()\n    )\n    average_ultimate_tensile_stress: UndefinedProperty | TensileStress = (\n        UndefinedProperty()\n    )\n    superconducting_parameterisation: SerializeAsAny[\n        SuperconductingParameterisationT_co\n    ] = UndefinedSuperconductingParameterisation()\n\n    field_validator(\"superconducting_parameterisation\", mode=\"before\")(\n        _superconduction_validation\n    )\n</code></pre>"},{"location":"source/reference/matproplib/properties/group/#matproplib.properties.group.DefaultProperties.density","title":"<code>density = UndefinedProperty()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/group/#matproplib.properties.group.DefaultProperties.poissons_ratio","title":"<code>poissons_ratio = UndefinedProperty()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/group/#matproplib.properties.group.DefaultProperties.residual_resistance_ratio","title":"<code>residual_resistance_ratio = UndefinedProperty()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/group/#matproplib.properties.group.DefaultProperties.thermal_conductivity","title":"<code>thermal_conductivity = UndefinedProperty()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/group/#matproplib.properties.group.DefaultProperties.youngs_modulus","title":"<code>youngs_modulus = UndefinedProperty()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/group/#matproplib.properties.group.DefaultProperties.shear_modulus","title":"<code>shear_modulus = UndefinedProperty()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/group/#matproplib.properties.group.DefaultProperties.bulk_modulus","title":"<code>bulk_modulus = UndefinedProperty()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/group/#matproplib.properties.group.DefaultProperties.coefficient_thermal_expansion","title":"<code>coefficient_thermal_expansion = UndefinedProperty()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/group/#matproplib.properties.group.DefaultProperties.specific_heat_capacity","title":"<code>specific_heat_capacity = UndefinedProperty()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/group/#matproplib.properties.group.DefaultProperties.electrical_resistivity","title":"<code>electrical_resistivity = UndefinedProperty()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/group/#matproplib.properties.group.DefaultProperties.magnetic_saturation","title":"<code>magnetic_saturation = UndefinedProperty()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/group/#matproplib.properties.group.DefaultProperties.magnetic_susceptibility","title":"<code>magnetic_susceptibility = UndefinedProperty()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/group/#matproplib.properties.group.DefaultProperties.viscous_remanent_magnetisation","title":"<code>viscous_remanent_magnetisation = UndefinedProperty()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/group/#matproplib.properties.group.DefaultProperties.coercive_field","title":"<code>coercive_field = UndefinedProperty()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/group/#matproplib.properties.group.DefaultProperties.minimum_yield_stress","title":"<code>minimum_yield_stress = UndefinedProperty()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/group/#matproplib.properties.group.DefaultProperties.average_yield_stress","title":"<code>average_yield_stress = UndefinedProperty()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/group/#matproplib.properties.group.DefaultProperties.minimum_ultimate_tensile_stress","title":"<code>minimum_ultimate_tensile_stress = UndefinedProperty()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/group/#matproplib.properties.group.DefaultProperties.average_ultimate_tensile_stress","title":"<code>average_ultimate_tensile_stress = UndefinedProperty()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/group/#matproplib.properties.group.DefaultProperties.superconducting_parameterisation","title":"<code>superconducting_parameterisation = UndefinedSuperconductingParameterisation()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/group/#matproplib.properties.group.props","title":"<code>props(*, density=False, poissons_ratio=False, residual_resistance_ratio=False, thermal_conductivity=False, youngs_modulus=False, shear_modulus=False, bulk_modulus=False, coefficient_thermal_expansion=False, specific_heat_capacity=False, electrical_resistivity=False, magnetic_saturation=False, magnetic_susceptibility=False, viscous_remanent_magnetisation=False, coercive_field=False, minimum_yield_stress=False, average_yield_stress=False, minimum_ultimate_tensile_stress=False, average_ultimate_tensile_stress=False, superconducting_parameterisation=None, property_group=DefaultProperties, reference=None, as_field=False, **extra_values)</code>","text":"<p>Property group generator</p> <p>Returns:</p> Type Description <code>PropertiesT_co</code> <p>The initialised property model</p> Notes <p>By default this function will create an empty property model. Each property can be initialised with an empty model by specifying True or an empty model or by any of the possible initialisation objects of a given property.</p> Source code in <code>matproplib/properties/group.py</code> <pre><code>def props(  # noqa: PLR0913\n    *,\n    density: Density | Ldefine = False,\n    poissons_ratio: PoissonsRatio | Ldefine = False,\n    residual_resistance_ratio: ResidualResistanceRatio | Ldefine = False,\n    thermal_conductivity: ThermalConductivity | Ldefine = False,\n    youngs_modulus: YoungsModulus | Ldefine = False,\n    shear_modulus: ShearModulus | Ldefine = False,\n    bulk_modulus: BulkModulus | Ldefine = False,\n    coefficient_thermal_expansion: CoefficientThermalExpansion | Ldefine = False,\n    specific_heat_capacity: SpecificHeatCapacity | Ldefine = False,\n    electrical_resistivity: ElectricalResistivity | Ldefine = False,\n    magnetic_saturation: MagneticSaturation | Ldefine = False,\n    magnetic_susceptibility: MagneticSusceptibility | Ldefine = False,\n    viscous_remanent_magnetisation: ViscousRemanentMagnetism | Ldefine = False,\n    coercive_field: CoerciveField | Ldefine = False,\n    minimum_yield_stress: YieldStress | Ldefine = False,\n    average_yield_stress: YieldStress | Ldefine = False,\n    minimum_ultimate_tensile_stress: TensileStress | Ldefine = False,\n    average_ultimate_tensile_stress: TensileStress | Ldefine = False,\n    superconducting_parameterisation: SuperconductingParameterisationT_co\n    | Literal[True]\n    | None = None,\n    property_group: type[PropertiesT_co] = DefaultProperties,\n    reference: References | None = None,\n    as_field: bool = False,\n    **extra_values: dict[str, DependentPhysicalProperty | DependentPhysicalPropertyTD],\n) -&gt; PropertiesT_co:\n    \"\"\"Property group generator\n\n    Returns\n    -------\n    :\n        The initialised property model\n\n    Notes\n    -----\n    By default this function will create an empty property model.\n    Each property can be initialised with an empty model by specifying True\n    or an empty model or by any of the possible initialisation objects of\n    a given property.\n    \"\"\"\n    data = {\n        \"density\": density,\n        \"poissons_ratio\": poissons_ratio,\n        \"residual_resistance_ratio\": residual_resistance_ratio,\n        \"thermal_conductivity\": thermal_conductivity,\n        \"youngs_modulus\": youngs_modulus,\n        \"shear_modulus\": shear_modulus,\n        \"bulk_modulus\": bulk_modulus,\n        \"coefficient_thermal_expansion\": coefficient_thermal_expansion,\n        \"specific_heat_capacity\": specific_heat_capacity,\n        \"electrical_resistivity\": electrical_resistivity,\n        \"magnetic_saturation\": magnetic_saturation,\n        \"magnetic_susceptibility\": magnetic_susceptibility,\n        \"viscous_remanent_magnetisation\": viscous_remanent_magnetisation,\n        \"coercive_field\": coercive_field,\n        \"minimum_yield_stress\": minimum_yield_stress,\n        \"average_yield_stress\": average_yield_stress,\n        \"minimum_ultimate_tensile_stress\": minimum_ultimate_tensile_stress,\n        \"average_ultimate_tensile_stress\": average_ultimate_tensile_stress,\n        **extra_values,\n    }\n\n    if superconducting_parameterisation is None:\n        validators = {}\n        sc = {}\n    else:\n        scp_n = \"superconducting_parameterisation\"\n        scp = superconducting_parameterisation\n        field = Field(\n            default=UndefinedSuperconductingParameterisation() if scp is True else scp,\n            validate_default=True,\n        )\n        sc = {scp_n: (SerializeAsAny[SuperconductingParameterisationT_co], field)}\n        validators = {\n            \"_superconduction_validation\": field_validator(scp_n, mode=\"before\")(\n                _superconduction_validation\n            )\n        }\n    model = create_model(\n        \"DynamicProperties\",\n        __base__=(Properties, Generic[SuperconductingParameterisationT_co]),\n        __validators__=validators,\n        reference=(References | None, reference),\n        **{\n            name: (\n                property_group.model_fields[name].annotation\n                if name in property_group.model_fields\n                else _get_dpp_type(name, value),\n                Field(\n                    default=UndefinedProperty() if value is True else value,\n                    validate_default=True,\n                ),\n            )\n            for name, value in data.items()\n            if value is not False\n        },\n        **sc,\n    )\n    if superconducting_parameterisation is not None:\n        model = model[\n            Union[  # noqa: UP007\n                tuple(\n                    sc\n                    for sc in all_subclasses(SuperconductingParameterisation)\n                    if not sc.__name__.startswith(\"_Dyn\")\n                )\n            ]\n        ]\n\n    if as_field:\n        return Field(validate_default=True, default_factory=model)\n    return model()\n</code></pre>"},{"location":"source/reference/matproplib/properties/independent/","title":"independent","text":"<p>Conditions of a Material</p>"},{"location":"source/reference/matproplib/properties/independent/#matproplib.properties.independent.UnVerifiedPhysicalProperty","title":"<code>UnVerifiedPhysicalProperty</code>","text":"<p>               Bases: <code>NDArrayOperatorsMixin</code></p> Source code in <code>matproplib/properties/independent.py</code> <pre><code>class UnVerifiedPhysicalProperty(np.lib.mixins.NDArrayOperatorsMixin):\n    def __init__(self, value, unit):\n        self.value = value\n        self.unit = unit\n\n    def __eq__(self, other: PhysicalProperty | UnVerifiedPhysicalProperty) -&gt; bool:\n        \"\"\"\n        Returns\n        -------\n        :\n            The boolean of equality\n\n        Raises\n        ------\n        TypeError\n            Unable to complete equality check\n        \"\"\"\n        if type(self) is not type(other):\n            try:\n                return not np.allclose(self.value, other)\n            except TypeError:\n                if hasattr(other, \"__eq__\"):\n                    return other.__eq__(self.value)\n                raise\n        else:\n            return not (\n                not np.allclose(self.value, other.value) or not self.unit == other.unit\n            )\n\n    def __hash__(self):\n        \"\"\"\n        Returns\n        -------\n        :\n            hash of object\n        \"\"\"\n        return hash((self.value, self.unit))\n\n    def __abs__(self):\n        return np.abs(self.value)\n\n    def __array_ufunc__(  # noqa: PLW3201\n        self, ufunc: np.ufunc, method: str, *inputs: Any, **kwargs: Any\n    ) -&gt; float | tuple[float, ...]:\n        \"\"\"Array options for physical properties\"\"\"  # noqa: DOC201\n        out = kwargs.get(\"out\", ())\n        for x in inputs + out:\n            if not isinstance(\n                x, np.ndarray | Number | PhysicalProperty | UnVerifiedPhysicalProperty\n            ):\n                return NotImplemented\n\n        inputs = tuple(\n            x.value\n            if isinstance(x, PhysicalProperty | UnVerifiedPhysicalProperty)\n            else x\n            for x in inputs\n        )\n        if out:\n            kwargs[\"out\"] = tuple(\n                x.value\n                if isinstance(x, PhysicalProperty | UnVerifiedPhysicalProperty)\n                else x\n                for x in out\n            )\n\n        result = getattr(ufunc, method)(*inputs, **kwargs)\n\n        if isinstance(result, tuple):\n            return tuple(\n                x.value\n                if isinstance(x, PhysicalProperty | UnVerifiedPhysicalProperty)\n                else x\n                for x in result\n            )\n        if isinstance(result, type(self)):\n            return result.value\n        return result\n\n    def __array_function__(self, func, types: tuple[type, ...], args, kwargs) -&gt; float:  # noqa: PLW3201\n        \"\"\"Array options for physical properties\"\"\"  # noqa: DOC201\n        if not all(\n            issubclass(\n                t, PhysicalProperty | UnVerifiedPhysicalProperty | Number | np.ndarray\n            )\n            for t in types\n        ):\n            return NotImplemented\n\n        args = tuple(\n            x.value\n            if isinstance(x, PhysicalProperty | UnVerifiedPhysicalProperty)\n            else x\n            for x in args\n        )\n        return func(*args, **kwargs)\n</code></pre>"},{"location":"source/reference/matproplib/properties/independent/#matproplib.properties.independent.UnVerifiedPhysicalProperty.value","title":"<code>value = value</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/independent/#matproplib.properties.independent.UnVerifiedPhysicalProperty.unit","title":"<code>unit = unit</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/independent/#matproplib.properties.independent.PhysicalProperty","title":"<code>PhysicalProperty</code>","text":"<p>               Bases: <code>BasePhysicalProperty</code>, <code>UnVerifiedPhysicalProperty</code></p> <p>Independent Physical Property model</p> Source code in <code>matproplib/properties/independent.py</code> <pre><code>class PhysicalProperty(BasePhysicalProperty, UnVerifiedPhysicalProperty):\n    \"\"\"Independent Physical Property model\"\"\"\n\n    @model_validator(mode=\"before\")\n    def _value_entry(self):\n        \"\"\"Validate value\"\"\"  # noqa: DOC201\n        if isinstance(self, float | int | np.ndarray | list):\n            return {\"value\": self}\n\n        if isinstance(self, Quantity):\n            return {\"value\": self.magnitude, \"unit\": self.units}\n\n        if isinstance(self, tuple) and len(self) == 2:  # noqa: PLR2004\n            return {\"value\": self[0], \"unit\": self[1]}\n\n        if isinstance(self, dict):\n            val = self.get(\"value\", None)\n            if isinstance(val, Quantity):\n                return {\"value\": val.magnitude, \"unit\": val.units}\n            if isinstance(val, tuple) and len(val) == 2:  # noqa: PLR2004\n                return {\"value\": val[0], \"unit\": val[1]}\n\n        return self\n\n    @model_validator(mode=\"after\")\n    def _unitify(self):\n        \"\"\"Convert value and unit to default\n\n        Raises\n        ------\n        ValueError\n            Failed unit conversion\n\n        Returns\n        -------\n        :\n            The property instance\n        \"\"\"\n        dunit = type(self).model_fields[\"unit\"].default\n        if isinstance(dunit, Unit) and self.unit == dunit:\n            return self\n\n        unit_val, default = super()._unitify()\n\n        if unit_val.units != default or not (\n            unit_val.magnitude == 1 or np.isclose(unit_val.magnitude, 1)\n        ):\n            object.__setattr__(  # noqa: PLC2801\n                self, \"value\", unit_conversion(unit_val * self.value, default)\n            )\n        object.__setattr__(self, \"unit\", default)  # noqa: PLC2801\n        return self\n\n    def value_as(self, unit: str | Unit) -&gt; float:\n        \"\"\"\n        Returns\n        -------\n        :\n            value in another unit\n\n        Raises\n        ------\n        ValueError\n            Failed unit conversion\n        \"\"\"\n        try:\n            return ureg.Quantity(self.value, self.unit).to(unit).magnitude\n        except DimensionalityError as de:\n            raise ValueError(\n                f\"Cannot convert from '{de.args[0]}' \"\n                f\"({de.args[2]}) to '{de.args[1]}' ({de.args[3]})\"\n            ) from None\n</code></pre>"},{"location":"source/reference/matproplib/properties/independent/#matproplib.properties.independent.PhysicalProperty.value_as","title":"<code>value_as(unit)</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>value in another unit</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Failed unit conversion</p> Source code in <code>matproplib/properties/independent.py</code> <pre><code>def value_as(self, unit: str | Unit) -&gt; float:\n    \"\"\"\n    Returns\n    -------\n    :\n        value in another unit\n\n    Raises\n    ------\n    ValueError\n        Failed unit conversion\n    \"\"\"\n    try:\n        return ureg.Quantity(self.value, self.unit).to(unit).magnitude\n    except DimensionalityError as de:\n        raise ValueError(\n            f\"Cannot convert from '{de.args[0]}' \"\n            f\"({de.args[2]}) to '{de.args[1]}' ({de.args[3]})\"\n        ) from None\n</code></pre>"},{"location":"source/reference/matproplib/properties/independent/#matproplib.properties.independent.Temperature","title":"<code>Temperature</code>","text":"<p>               Bases: <code>PhysicalProperty</code></p> <p>Temperature of a material</p> Source code in <code>matproplib/properties/independent.py</code> <pre><code>class Temperature(PhysicalProperty):\n    \"\"\"Temperature of a material\"\"\"\n\n    unit: Unit | str = ureg.Unit(\"K\")\n\n    @model_validator(mode=\"after\")\n    def _k_below_0(self):\n        \"\"\"Validate negative temperature\n\n        Raises\n        ------\n        ValueError\n            Less than 0K\n        \"\"\"  # noqa: DOC201\n        value = (\n            ureg.Quantity(self.value, self.unit).to(\"K\")\n            if self.unit != ureg.Unit(\"K\")\n            else self.value\n        )\n        if any(np.atleast_1d(np.less(value, 0))):\n            raise ValueError(\"Temperature cannot be below 0 K\")\n        return self\n</code></pre>"},{"location":"source/reference/matproplib/properties/independent/#matproplib.properties.independent.Temperature.unit","title":"<code>unit = ureg.Unit('K')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/independent/#matproplib.properties.independent.Pressure","title":"<code>Pressure</code>","text":"<p>               Bases: <code>PhysicalProperty</code></p> <p>Pressure on a material</p> Source code in <code>matproplib/properties/independent.py</code> <pre><code>class Pressure(PhysicalProperty):\n    \"\"\"Pressure on a material\"\"\"\n\n    unit: Unit | str = ureg.Unit(\"Pa\")\n</code></pre>"},{"location":"source/reference/matproplib/properties/independent/#matproplib.properties.independent.Pressure.unit","title":"<code>unit = ureg.Unit('Pa')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/independent/#matproplib.properties.independent.MagneticField","title":"<code>MagneticField</code>","text":"<p>               Bases: <code>PhysicalProperty</code></p> <p>Magnetic field on a material</p> Source code in <code>matproplib/properties/independent.py</code> <pre><code>class MagneticField(PhysicalProperty):\n    \"\"\"Magnetic field on a material\"\"\"\n\n    unit: Unit | str = ureg.Unit(\"T\")\n</code></pre>"},{"location":"source/reference/matproplib/properties/independent/#matproplib.properties.independent.MagneticField.unit","title":"<code>unit = ureg.Unit('T')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/independent/#matproplib.properties.independent.Strain","title":"<code>Strain</code>","text":"<p>               Bases: <code>PhysicalProperty</code></p> <p>Strain on a material</p> Source code in <code>matproplib/properties/independent.py</code> <pre><code>class Strain(PhysicalProperty):\n    \"\"\"Strain on a material\"\"\"\n\n    unit: Unit | str = \"\"\n</code></pre>"},{"location":"source/reference/matproplib/properties/independent/#matproplib.properties.independent.Strain.unit","title":"<code>unit = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/independent/#matproplib.properties.independent.NeutronDamage","title":"<code>NeutronDamage</code>","text":"<p>               Bases: <code>PhysicalProperty</code></p> <p>Neutron damage of a material</p> Source code in <code>matproplib/properties/independent.py</code> <pre><code>class NeutronDamage(PhysicalProperty):\n    \"\"\"Neutron damage of a material\"\"\"\n\n    unit: Unit | str = \"dpa\"\n</code></pre>"},{"location":"source/reference/matproplib/properties/independent/#matproplib.properties.independent.NeutronDamage.unit","title":"<code>unit = 'dpa'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/independent/#matproplib.properties.independent.NeutronFluence","title":"<code>NeutronFluence</code>","text":"<p>               Bases: <code>PhysicalProperty</code></p> <p>Neutron damage of a material</p> Source code in <code>matproplib/properties/independent.py</code> <pre><code>class NeutronFluence(PhysicalProperty):\n    \"\"\"Neutron damage of a material\"\"\"\n\n    unit: Unit | str = \"1/m^2\"\n</code></pre>"},{"location":"source/reference/matproplib/properties/independent/#matproplib.properties.independent.NeutronFluence.unit","title":"<code>unit = '1/m^2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/independent/#matproplib.properties.independent.CurrentDensity","title":"<code>CurrentDensity</code>","text":"<p>               Bases: <code>PhysicalProperty</code></p> <p>Current density of a material</p> Source code in <code>matproplib/properties/independent.py</code> <pre><code>class CurrentDensity(PhysicalProperty):\n    \"\"\"Current density of a material\"\"\"\n\n    unit: Unit | str = \"A/m^2\"\n</code></pre>"},{"location":"source/reference/matproplib/properties/independent/#matproplib.properties.independent.CurrentDensity.unit","title":"<code>unit = 'A/m^2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/independent/#matproplib.properties.independent.Volume","title":"<code>Volume</code>","text":"<p>               Bases: <code>PhysicalProperty</code></p> <p>Volume of a material</p> Source code in <code>matproplib/properties/independent.py</code> <pre><code>class Volume(PhysicalProperty):\n    \"\"\"Volume of a material\"\"\"\n\n    unit: Unit | str = \"m^3\"\n</code></pre>"},{"location":"source/reference/matproplib/properties/independent/#matproplib.properties.independent.Volume.unit","title":"<code>unit = 'm^3'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/independent/#matproplib.properties.independent.pp","title":"<code>pp(name, unit)</code>","text":"Source code in <code>matproplib/properties/independent.py</code> <pre><code>def pp(name: str, unit: str | Unit) -&gt; PhysicalProperty:\n    return create_model(\n        name,\n        __base__=PhysicalProperty,\n        unit=(Unit | str, Field(default=unit, validate_default=True)),\n    )\n</code></pre>"},{"location":"source/reference/matproplib/properties/mixture/","title":"mixture","text":"<p>Mixtures of properties</p>"},{"location":"source/reference/matproplib/properties/mixture/#matproplib.properties.mixture.DependentPhysicalPropertyT","title":"<code>DependentPhysicalPropertyT = TypeVar('DependentPhysicalPropertyT', bound=DependentPhysicalProperty)</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/mixture/#matproplib.properties.mixture.Mixture","title":"<code>Mixture</code>","text":"<p>               Bases: <code>PMBaseModel</code>, <code>Generic[DependentPhysicalPropertyT]</code></p> <p>Mixture of properties</p> <p>Mixes using atomic fractions</p> Source code in <code>matproplib/properties/mixture.py</code> <pre><code>class Mixture(PMBaseModel, Generic[DependentPhysicalPropertyT]):\n    \"\"\"\n    Mixture of properties\n\n    Mixes using atomic fractions\n    \"\"\"\n\n    dpp: list[DependentPhysicalPropertyT]\n    fractions: NDArray[Shape[\"* x\"], Number] = Field(default=[1])  # noqa: F722\n    unit: Unit | str\n    _unit_warn: bool = False\n\n    @staticmethod\n    def _fix_sizes(out: list[np.ndarray | float]):\n        if any(isinstance(o, np.ndarray) for o in out):\n            sizes = np.unique([o.size if isinstance(o, np.ndarray) else 1 for o in out])\n            if sizes.size &gt; 2:  # noqa: PLR2004\n                raise NotImplementedError(\"Cannot mix independently sized arrays\")\n            if sizes.size == 2 and 1 in sizes:  # noqa: PLR2004\n                size = max(sizes)\n                for no, o in enumerate(out):\n                    if not isinstance(o, np.ndarray):\n                        out[no] = np.full(size, o)\n        return np.asarray(out)\n\n    @model_validator(mode=\"after\")\n    def _warn_on_unit_difference(self):\n        units = [dp.unit != self.unit for dp in self.dpp[1:]]\n        if any(units) and not self._unit_warn:\n            log.warning(\n                f\"Output units for {type(self.dpp[0]).__name__} \"\n                f\"are not the same across mixture. Outputting in {self.unit:~P}.\"\n            )\n            self._unit_warn = True\n            self.__call__ = lambda *args, unit=self.unit, **kwargs: self.value_as(\n                *args, unit=unit, **kwargs\n            )\n\n        return self\n\n    @field_validator(\"fractions\", mode=\"after\")\n    @classmethod\n    def _fraction_array(cls, value):\n        return np.asarray(value)\n\n    def _fractional_calc(self, out: list[float | np.ndarray]):\n        return np.einsum(\n            \"i..., i\",\n            self._fix_sizes(out),\n            self.fractions,\n        )\n\n    def value_as(self, op_cond: OpCondT, unit: str | Unit, *args, **kwargs) -&gt; float:\n        \"\"\"\n        Returns\n        -------\n        :\n            value in another unit\n\n        Raises\n        ------\n        ValueError\n            Failed unit conversion\n        \"\"\"\n        return self._fractional_calc([\n            d.value_as(op_cond, unit, *args, **kwargs) for d in self.dpp\n        ])\n\n    def __call__(self, op_cond: OpCondT, *args, **kwargs) -&gt; float:\n        \"\"\"Helper to inject and modify conditions as required\n\n        Returns\n        -------\n        :\n            Property value at conditons\n        \"\"\"\n        return self._fractional_calc([d(op_cond, *args, **kwargs) for d in self.dpp])\n</code></pre>"},{"location":"source/reference/matproplib/properties/mixture/#matproplib.properties.mixture.Mixture.dpp","title":"<code>dpp</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/mixture/#matproplib.properties.mixture.Mixture.fractions","title":"<code>fractions = Field(default=[1])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/mixture/#matproplib.properties.mixture.Mixture.unit","title":"<code>unit</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/properties/mixture/#matproplib.properties.mixture.Mixture.value_as","title":"<code>value_as(op_cond, unit, *args, **kwargs)</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>value in another unit</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Failed unit conversion</p> Source code in <code>matproplib/properties/mixture.py</code> <pre><code>def value_as(self, op_cond: OpCondT, unit: str | Unit, *args, **kwargs) -&gt; float:\n    \"\"\"\n    Returns\n    -------\n    :\n        value in another unit\n\n    Raises\n    ------\n    ValueError\n        Failed unit conversion\n    \"\"\"\n    return self._fractional_calc([\n        d.value_as(op_cond, unit, *args, **kwargs) for d in self.dpp\n    ])\n</code></pre>"},{"location":"source/reference/matproplib/tools/neutronics/","title":"neutronics","text":"<p>Materials neutronics tools</p>"},{"location":"source/reference/matproplib/tools/neutronics/#matproplib.tools.neutronics.NM_FRACTION_TYPE_MAPPING","title":"<code>NM_FRACTION_TYPE_MAPPING = {'atomic': 'ao', 'mass': 'wo', 'volume': 'vo'}</code>  <code>module-attribute</code>","text":""},{"location":"source/reference/matproplib/tools/neutronics/#matproplib.tools.neutronics.to_openmc_material","title":"<code>to_openmc_material(name, density_unit, percent_type, density, packing_fraction=1.0, enrichment=None, enrichment_target=None, temperature=None, elements=None, isotopes=None, enrichment_type=None, material_id=None, *, temperature_to_neutronics_code=True)</code>","text":"<p>Convert material to OpenMC material</p> <p>Returns:</p> Type Description <code>Material</code> <p>The openmc material</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>neither density or atoms and volume per unit cell specified</p> <code>ValueError</code> <p>Arrays used in temperature specification</p> Source code in <code>matproplib/tools/neutronics.py</code> <pre><code>def to_openmc_material(\n    name: str,\n    density_unit: str,\n    percent_type: Literal[\"atomic\", \"mass\"],\n    density: float,\n    packing_fraction: float = 1.0,\n    enrichment: float | None = None,\n    enrichment_target: str | None = None,\n    temperature: float | None = None,\n    elements: dict[str, float] | None = None,\n    isotopes: dict[str, float] | None = None,\n    enrichment_type: str | None = None,\n    material_id: int | None = None,\n    *,\n    temperature_to_neutronics_code: bool = True,\n) -&gt; openmc.Material:\n    \"\"\"\n    Convert material to OpenMC material\n\n    Returns\n    -------\n    :\n        The openmc material\n\n    Raises\n    ------\n    ValueError\n        neither density or atoms and volume per unit cell specified\n    ValueError\n        Arrays used in temperature specification\n    \"\"\"\n    nm_percent_type = NM_FRACTION_TYPE_MAPPING[percent_type]\n    enrichment_type = NM_FRACTION_TYPE_MAPPING.get(enrichment_type)\n    en_el = _enrichment_check(enrichment, enrichment_target, enrichment_type)\n\n    with _get_openmc() as openmc:\n        material = openmc.Material(name=name, material_id=material_id)\n\n        if isotopes:\n            for is_name, frac in isotopes.items():\n                material.add_nuclide(is_name, frac, nm_percent_type)\n\n        if elements:\n            for el_name, frac in elements.items():\n                extra = (\n                    {\n                        \"enrichment\": enrichment,\n                        \"enrichment_target\": enrichment_target,\n                        \"enrichment_type\": enrichment_type,\n                    }\n                    if el_name == en_el\n                    else {}\n                )\n                material.add_element(\n                    el_name, frac, percent_type=nm_percent_type, **extra\n                )\n\n        # Ordering of nucleide can effect results\n        material._nuclides = sorted(material._nuclides)  # noqa: SLF001\n        material.set_density(density_unit.replace(\"^\", \"\"), density * packing_fraction)\n        if temperature_to_neutronics_code:\n            material.temperature = temperature\n    return material\n</code></pre>"},{"location":"source/reference/matproplib/tools/neutronics/#matproplib.tools.neutronics.density_from_unit_cell","title":"<code>density_from_unit_cell(atoms_in_sample, atoms_per_unit_cell, average_molar_mass, volume_of_unit_cell)</code>","text":"<p>Density from a unit cell</p> Source code in <code>matproplib/tools/neutronics.py</code> <pre><code>def density_from_unit_cell(\n    atoms_in_sample: int,\n    atoms_per_unit_cell: int,\n    average_molar_mass: float,\n    volume_of_unit_cell: float,\n) -&gt; float:\n    \"\"\"Density from a unit cell\"\"\"  # noqa: DOC201\n    molar_mass = atoms_in_sample * average_molar_mass\n    mass = atoms_per_unit_cell * molar_mass * ureg.Quantity(\"amu\").to(\"kg\").magnitude\n    return mass / volume_of_unit_cell\n</code></pre>"},{"location":"source/reference/matproplib/tools/neutronics/#matproplib.tools.neutronics.to_fispact_material","title":"<code>to_fispact_material(volume_in_cm3, mass_density, nucleide_atom_per_cm3, decimal_places=8, additional_end_lines=None)</code>","text":"<p>Fispact material card using the DENSITY and FUEL keywords</p> <p>Returns:</p> Type Description <code>str</code> <p>Material card as string</p> Notes <p>See https://fispact.ukaea.uk/wiki/Keyword:FUEL and https://fispact.ukaea.uk/wiki/Keyword:DENSITY</p> Source code in <code>matproplib/tools/neutronics.py</code> <pre><code>def to_fispact_material(\n    volume_in_cm3: float,\n    mass_density: float,\n    nucleide_atom_per_cm3: dict[str, float],\n    decimal_places: int = 8,\n    additional_end_lines: list[str] | None = None,\n) -&gt; str:\n    \"\"\"Fispact material card using the DENSITY and FUEL keywords\n\n    Returns\n    -------\n    :\n        Material card as string\n\n    Notes\n    -----\n    See https://fispact.ukaea.uk/wiki/Keyword:FUEL and\n    https://fispact.ukaea.uk/wiki/Keyword:DENSITY\n\n    \"\"\"\n    mat_card = [\n        f\"DENSITY {mass_density:.{decimal_places}E}\",\n        f\"FUEL {len(nucleide_atom_per_cm3)}\",\n    ]\n    mat_card.extend(\n        f\"{isotope}  {volume_in_cm3 * atoms_cm3:.{decimal_places}E}\"\n        for isotope, atoms_cm3 in nucleide_atom_per_cm3.items()\n    )\n    return _general_end(mat_card, additional_end_lines)\n</code></pre>"},{"location":"source/reference/matproplib/tools/neutronics/#matproplib.tools.neutronics.to_serpent_material","title":"<code>to_serpent_material(name, mass_density, nucleides, temperature=None, decimal_places=8, zaid_suffix='', additional_end_lines=None, *, temperature_to_neutronics_code=False)</code>","text":"<p>Serpent material card</p> <p>Returns:</p> Type Description <code>str</code> <p>Material card as a string</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Use of arrays for temperature</p> Notes <p>https://serpent.vtt.fi/mediawiki/index.php/Input_syntax_manual#mat_(material_definition) Assumes density is in g/cm^3</p> Source code in <code>matproplib/tools/neutronics.py</code> <pre><code>def to_serpent_material(\n    name: str,\n    mass_density: float,\n    nucleides: list[tuple[ElementFraction, Literal[\"mass\", \"atomic\"]]],\n    temperature: float | None = None,\n    decimal_places: int = 8,\n    zaid_suffix: str = \"\",\n    additional_end_lines: list[str] | None = None,\n    *,\n    temperature_to_neutronics_code: bool = False,\n) -&gt; str:\n    \"\"\"Serpent material card\n\n    Returns\n    -------\n    :\n        Material card as a string\n\n    Raises\n    ------\n    ValueError\n        Use of arrays for temperature\n\n    Notes\n    -----\n    https://serpent.vtt.fi/mediawiki/index.php/Input_syntax_manual#mat_(material_definition)\n    Assumes density is in g/cm^3\n    \"\"\"\n    mat_card = [f\"mat {name} -{abs(mass_density):.{decimal_places}e}\"]\n    if temperature_to_neutronics_code and temperature is not None:\n        if isinstance(temperature, np.ndarray) and temperature.size != 1:\n            raise ValueError(\n                \"Only singular temperature value can be passed into neutronics material\"\n            )\n        mat_card[0] += f\" tmp {temperature:.2f}\"\n\n    return _mcnp_serpert_ending(\n        mat_card, nucleides, zaid_suffix, decimal_places, additional_end_lines\n    )\n</code></pre>"},{"location":"source/reference/matproplib/tools/neutronics/#matproplib.tools.neutronics.to_mcnp_material","title":"<code>to_mcnp_material(material_id, mass_density, nucleides, name='', zaid_suffix='', decimal_places=8, additional_end_lines=None)</code>","text":"<p>MCNP6 Material card</p> <p>Returns:</p> Type Description <code>str</code> <p>Material card as a string</p> Notes <p>mcnp.lanl.gov/pdf_files/Book_MonteCarlo_2024_ShultisBahadori_AnMCNPPrimer.pdf</p> Source code in <code>matproplib/tools/neutronics.py</code> <pre><code>def to_mcnp_material(\n    material_id: int,\n    mass_density: float,\n    nucleides: list[tuple[ElementFraction, Literal[\"mass\", \"atomic\"]]],\n    name: str = \"\",\n    zaid_suffix: str = \"\",\n    decimal_places: int = 8,\n    additional_end_lines: list[str] | None = None,\n) -&gt; str:\n    \"\"\"MCNP6 Material card\n\n    Returns\n    -------\n    :\n        Material card as a string\n\n    Notes\n    -----\n    mcnp.lanl.gov/pdf_files/Book_MonteCarlo_2024_ShultisBahadori_AnMCNPPrimer.pdf\n    \"\"\"\n    mat_card = [\n        \"c     \" + name + \" density \" + f\"{mass_density:.{decimal_places}e}\" + \" g/cm3\",\n        f\"M{material_id: &lt;5}\"\n        + _mcnp_serpert_extras(nucleides[0], zaid_suffix, decimal_places),\n    ]\n\n    return _mcnp_serpert_ending(\n        mat_card, nucleides[1:], zaid_suffix, decimal_places, additional_end_lines\n    )\n</code></pre>"},{"location":"source/reference/matproplib/tools/plotting/","title":"plotting","text":"<p>Materials plotting tools</p>"},{"location":"source/reference/matproplib/tools/plotting/#matproplib.tools.plotting.plot_superconductor","title":"<code>plot_superconductor(sc_parameterisation, t_min, t_max, b_min, b_max, strain, n_points=50)</code>","text":"<p>Plot the critical current density of a superconductor parameterisation.</p> <p>Parameters:</p> Name Type Description Default <code>sc_parameterisation</code> <code>SuperconductingParameterisation</code> <p>The superconductor parameterisation to plot.</p> required <code>t_min</code> <code>float</code> <p>Minimum temperature in K.</p> required <code>t_max</code> <code>float</code> <p>Maximum temperature in K.</p> required <code>b_min</code> <code>float</code> <p>Minimum magnetic field in T.</p> required <code>b_max</code> <code>float</code> <p>Maximum magnetic field in T.</p> required <code>strain</code> <code>float</code> <p>Strain value to use for the plot.</p> required <code>n_points</code> <code>int</code> <p>Number of points to use for the plot, by default 100.</p> <code>50</code> <p>Returns:</p> Type Description <p>Figure</p> <p>Axes</p> Source code in <code>matproplib/tools/plotting.py</code> <pre><code>def plot_superconductor(\n    sc_parameterisation: SuperconductingParameterisation,\n    t_min: float,\n    t_max: float,\n    b_min: float,\n    b_max: float,\n    strain: float,\n    n_points: int = 50,\n):\n    \"\"\"Plot the critical current density of a superconductor parameterisation.\n\n    Parameters\n    ----------\n    sc_parameterisation:\n        The superconductor parameterisation to plot.\n    t_min:\n        Minimum temperature in K.\n    t_max:\n        Maximum temperature in K.\n    b_min:\n        Minimum magnetic field in T.\n    b_max:\n        Maximum magnetic field in T.\n    strain:\n        Strain value to use for the plot.\n    n_points:\n        Number of points to use for the plot, by default 100.\n\n    Returns\n    -------\n    :\n        Figure\n    :\n        Axes\n    \"\"\"\n    temperatures = np.linspace(t_min, t_max, n_points)\n    magnetic_fields = np.linspace(b_min, b_max, n_points)\n\n    xx, yy = np.meshgrid(temperatures, magnetic_fields)\n    op_cond = OperationalConditions(\n        temperature=xx.flatten(), magnetic_field=yy.flatten(), strain=strain\n    )\n    j_crit = sc_parameterisation.critical_current_density(op_cond).reshape(xx.shape)\n\n    f, ax = plt.subplots()\n    cm = ax.contourf(xx, yy, j_crit, cmap=\"viridis\")\n    f.colorbar(cm, label=\"Critical current denstiy [A/m^2]\")\n    ax.set_title(\n        f\"{sc_parameterisation.name} superconducting parameterisation critical surface\"\n    )\n    ax.set_xlabel(\"Temperature [K]\")\n    ax.set_ylabel(\"Magnetic field [T]\")\n    return f, ax\n</code></pre>"},{"location":"source/reference/matproplib/tools/serialisation/","title":"serialisation","text":"<p>Serialisation methods for materials</p>"},{"location":"source/reference/matproplib/tools/serialisation/#matproplib.tools.serialisation.LambdaInspection","title":"<code>LambdaInspection</code>  <code>dataclass</code>","text":"<p>Represent the inspection of the callable given as a lambda.</p> Source code in <code>matproplib/tools/serialisation.py</code> <pre><code>@dataclass\nclass LambdaInspection:\n    \"\"\"Represent the inspection of the callable given as a lambda.\"\"\"\n\n    atok: asttokens.ASTTokens\n    node: ast.Lambda\n    text: str = field(init=False)\n\n    def __post_init__(self):  # noqa: D105\n        self.text = ast.unparse(\n            ast.parse(self.atok.get_text(self.node).replace(\"\\n\", \"\"))\n        )\n</code></pre>"},{"location":"source/reference/matproplib/tools/serialisation/#matproplib.tools.serialisation.LambdaInspection.atok","title":"<code>atok</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/tools/serialisation/#matproplib.tools.serialisation.LambdaInspection.node","title":"<code>node</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/tools/serialisation/#matproplib.tools.serialisation.LambdaInspection.text","title":"<code>text = field(init=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/tools/serialisation/#matproplib.tools.serialisation.pickle_base64","title":"<code>pickle_base64(obj)</code>","text":"<p>Pickle an object to a base64 string</p> Source code in <code>matproplib/tools/serialisation.py</code> <pre><code>def pickle_base64(obj) -&gt; str:\n    \"\"\"Pickle an object to a base64 string\"\"\"  # noqa: DOC201\n    return base64.b64encode(pickle.dumps(obj))\n</code></pre>"},{"location":"source/reference/matproplib/tools/serialisation/#matproplib.tools.serialisation.stringify_function","title":"<code>stringify_function(obj)</code>","text":"<p>Turn a function into its python code string</p> Source code in <code>matproplib/tools/serialisation.py</code> <pre><code>def stringify_function(obj) -&gt; str:\n    \"\"\"Turn a function into its python code string\"\"\"  # noqa: DOC201\n    src = inspect.getsource(obj)\n    psrc = ast.parse(dedent(src))\n\n    decs: list[ast.Call] = psrc.body[0].decorator_list\n    for ind in range(len(decs)):\n        if decs[ind].func.id == \"dependentphysicalproperty\":\n            del decs[ind]\n    return ast.unparse(psrc)\n</code></pre>"},{"location":"source/reference/matproplib/tools/serialisation/#matproplib.tools.serialisation.deserialise","title":"<code>deserialise(obj)</code>","text":"<p>Deserialise a python code string</p> Source code in <code>matproplib/tools/serialisation.py</code> <pre><code>def deserialise(obj: str) -&gt; Callable:\n    \"\"\"Deserialise a python code string\"\"\"\n    raise NotImplementedError(\"Deserialising raw functions is not currently implemented\")\n</code></pre>"},{"location":"source/reference/matproplib/tools/serialisation/#matproplib.tools.serialisation.is_lambda","title":"<code>is_lambda(func)</code>","text":"<p>Check whether the callable is a lambda function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>FunctionType | Callable[..., Any]</code> <p>callable function</p> required <p>Returns:</p> Type Description <code>bool</code> <p>if func is defined as lambda function</p> Source code in <code>matproplib/tools/serialisation.py</code> <pre><code>def is_lambda(func: FunctionType | Callable[..., Any]) -&gt; bool:\n    \"\"\"\n    Check whether the callable is a lambda function.\n\n    Parameters\n    ----------\n    func:\n        callable function\n\n    Returns\n    -------\n    :\n        if func is defined as lambda function\n    \"\"\"\n    return callable(func) and getattr(func, \"__name__\", \"\") == \"&lt;lambda&gt;\"\n</code></pre>"},{"location":"source/reference/matproplib/tools/serialisation/#matproplib.tools.serialisation.inspect_lambda","title":"<code>inspect_lambda(func)</code>","text":"<p>Parse the file in which func resides and figure out the corresponding lambda AST node</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Any]</code> <p>The lambda function</p> required <p>Returns:</p> Type Description <code>LambdaInspection</code> <p>Inspected lambda function</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Lambda AST node not found</p> Source code in <code>matproplib/tools/serialisation.py</code> <pre><code>def inspect_lambda(func: Callable[..., Any]) -&gt; LambdaInspection:  # noqa: C901, PLR0912\n    \"\"\"\n    Parse the file in which func resides and figure out the corresponding lambda AST node\n\n    Parameters\n    ----------\n    func:\n        The lambda function\n\n    Returns\n    -------\n    :\n        Inspected lambda function\n\n    Raises\n    ------\n    ValueError\n        Lambda AST node not found\n    \"\"\"\n    # Parse the whole file and find the AST node of the func lambda.\n    # This is necessary func.__code__ or getsource gives us only a line number which is\n    # too vague to find the lambda node.\n    lines, func_lineno = inspect.findsource(func)\n    atok = asttokens.ASTTokens(\"\".join(lines), parse=True)\n    parent_of = dict(_walk_with_parent(atok.tree))\n\n    # node of the lambda wrapping layer\n    call_node = None\n\n    for node in ast.walk(atok.tree):\n        if isinstance(node, ast.Lambda) and node.lineno - 1 == func_lineno:\n            # Go up to the parent node\n            ancestor = parent_of[node]\n            if ancestor is None:\n                raise ValueError(\n                    \"Expected a parent of the func's lambda AST node, but got None\"\n                )\n\n            while ancestor is not None and not isinstance(ancestor, ast.Call):\n                ancestor = parent_of[ancestor]\n\n            if ancestor is None:\n                raise ValueError(\n                    \"Expected to find a Call AST node above the the func's lambda AST \"\n                    \"node, but found none\"\n                )\n\n            if not isinstance(ancestor, ast.Call):\n                raise ValueError\n            call_node = ancestor\n            break\n\n    if call_node is None:\n        raise ValueError(\"Expected call_node to be set in the previous execution.\")\n\n    if len(call_node.args) &gt; 0 and isinstance(call_node.args[0], ast.Lambda):\n        return LambdaInspection(atok, call_node.args[0])\n    if len(call_node.keywords) &gt; 0:  # noqa: PLR1702\n        for keyword in call_node.keywords:\n            # functional definition\n            if keyword.arg == \"value\" and isinstance(keyword.value, ast.Lambda):\n                return LambdaInspection(atok, keyword.value)\n            # inline lambda\n            if keyword.lineno - 1 == func_lineno and isinstance(\n                keyword.value, ast.Lambda\n            ):\n                return LambdaInspection(atok, keyword.value)\n            # dictionary definition\n            if keyword.lineno == func_lineno:\n                if isinstance(keyword.value, ast.Dict):\n                    for no, key in enumerate(keyword.value.keys):\n                        if key.value == \"value\" and isinstance(\n                            keyword.value.values[no], ast.Lambda\n                        ):\n                            return LambdaInspection(atok, keyword.value.values[no])\n                    raise NotImplementedError(f\"No lambda: {keyword.value}\")\n                raise NotImplementedError(f\"Unknown type: {keyword.value}\")\n        raise NotImplementedError(f\"line number not found: {call_node.keywords}\")\n    raise NotImplementedError(f\"No keyword found: {call_node}\")\n</code></pre>"},{"location":"source/reference/matproplib/tools/tools/","title":"tools","text":"<p>Miscellaneous tools for matproplib package</p>"},{"location":"source/reference/matproplib/tools/tools/#matproplib.tools.tools.From1DData","title":"<code>From1DData</code>","text":"<p>1-D Data interpolation from condition</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Sequence[float]</code> <p>Array of condition</p> required <code>y</code> <code>Sequence[float]</code> <p>Array of resultant quantity</p> required <code>condition</code> <code>str</code> <p>condition name</p> required Source code in <code>matproplib/tools/tools.py</code> <pre><code>class From1DData:\n    \"\"\"1-D Data interpolation from condition\n\n    Parameters\n    ----------\n    x:\n        Array of condition\n    y:\n        Array of resultant quantity\n    condition:\n        condition name\n    \"\"\"\n\n    def __init__(self, x: Sequence[float], y: Sequence[float], condition: str):\n        self.x = np.asarray(x)\n        self.y = np.asarray(y)\n        self.condition = condition\n\n    def __call__(self, op_cond: OpCondT):\n        \"\"\"Call the interpolator\"\"\"  # noqa: DOC201\n        return np.interp(getattr(op_cond, self.condition), self.x, self.y)\n</code></pre>"},{"location":"source/reference/matproplib/tools/tools/#matproplib.tools.tools.From1DData.x","title":"<code>x = np.asarray(x)</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/tools/tools/#matproplib.tools.tools.From1DData.y","title":"<code>y = np.asarray(y)</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/tools/tools/#matproplib.tools.tools.From1DData.condition","title":"<code>condition = condition</code>  <code>instance-attribute</code>","text":""},{"location":"source/reference/matproplib/tools/tools/#matproplib.tools.tools.annotate_reference","title":"<code>annotate_reference(reference, annotation)</code>","text":"<p>Returns:</p> Type Description <code>References</code> <p>Annotated a reference object</p> Source code in <code>matproplib/tools/tools.py</code> <pre><code>def annotate_reference(reference: References, annotation: str) -&gt; References:\n    \"\"\"\n    Returns\n    -------\n    :\n        Annotated a reference object\n    \"\"\"\n    reference = deepcopy(reference)\n    reference[\"id\"] += annotation\n    reference[\"annote\"] = f\"{reference.get('annote', '')} {annotation}\".strip(\" \")\n    return reference\n</code></pre>"},{"location":"source/reference/matproplib/tools/tools/#matproplib.tools.tools.kludge_linear_spline","title":"<code>kludge_linear_spline(x, x_kludge, width)</code>","text":"<p>Kludge a value below a certain minimum value with linear slope and cubic spline transition.</p> <p>For x &lt; x_kludge:     0.0 &lt; x &lt; x_kludge</p> <p>Returns:</p> Type Description <code>float</code> <p>Linear kludge with cubic spline transition.</p> Notes <p>This is a kludge to avoid negative values by providing a smooth transition from the intended function to a linear function below a certain minimum value. The transition is cubic spline based on the minimum value and a width parameter. There is still the potential to return negative values if the input is much lower than the input which first produces a negative value.</p> Source code in <code>matproplib/tools/tools.py</code> <pre><code>@np.vectorize\ndef kludge_linear_spline(x: float, x_kludge: float, width: float) -&gt; float:\n    \"\"\"Kludge a value below a certain minimum value with\n    linear slope and cubic spline transition.\n\n    For x &lt; x_kludge:\n        0.0 &lt; x &lt; x_kludge\n\n    Returns\n    -------\n    :\n        Linear kludge with cubic spline transition.\n\n    Notes\n    -----\n    This is a kludge to avoid negative values by providing a smooth transition from the\n    intended function to a linear function below a certain minimum value.\n    The transition is cubic spline based on the minimum value and a width parameter.\n    There is still the potential to return negative values if the input is much lower\n    than the input which first produces a negative value.\n    \"\"\"\n    p0 = 1e-8  # Chosen to give a very shallow slope to 0.0\n    x0 = x_kludge - width\n    x1 = x_kludge + width\n    y0 = x_kludge\n    y1 = x_kludge + width\n\n    if x &lt; x0:\n        return max(0.0, p0 * x + y0)\n    if x &lt; x1:\n        return _kludge_spline(x, x0, x1, y0, y1, p0)\n    return x\n</code></pre>"}]}